<?xml version="1.0"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "/usr/share/sgml/docbook/xml-dtd-4.1/docbookx.dtd" [

  <!-- Redefinition of paramdef to permit defaultvalue -->
  <!ELEMENT paramdef (#PCDATA 
		  | replaceable 
		  | parameter | defaultvalue
		  | funcparams)*>
  <!-- Additional element: defaultvalue -->
  <!ELEMENT defaultvalue (#PCDATA)>
  <!-- Additional markup for classes -->
  <!ELEMENT classdescription (classdef, (para | itemizedlist
                                         | methoddescription)*)>
  <!ATTLIST classdescription id ID #IMPLIED
                             role CDATA #IMPLIED
                             xreflabel CDATA #IMPLIED>
  <!ENTITY % local.synop.class "|classdescription">
  <!ELEMENT classdef (#PCDATA | class | classinfo)*>
  <!ELEMENT class (#PCDATA)>
  <!ELEMENT classinfo (#PCDATA)>
  <!ELEMENT methoddescription (methoddef, (void | varargs | paramdef+),
                               (para | itemizedlist)*)>
  <!ELEMENT methoddef (#PCDATA | method)*>
  <!ELEMENT method (#PCDATA)>

  <!ENTITY python-url "http://www.python.org">
  <!ENTITY python-tutorial-url "http://www.python.org/doc/tut/tut.html">
  <!ENTITY python-books-url "http://www.python.org/doc/Books.html">
  <!ENTITY netcdf-url "http://www.unidata.ucar.edu/packages/netcdf/">

  <!ENTITY Modules SYSTEM "Scientific.xml">

]>


<book id="ScientificPython">

<bookinfo>
  <date>2002-6-13</date>
  <title>ScientificPython User's Guide</title>
  <releaseinfo>for ScientificPython 2.4</releaseinfo>
  <author>
    <firstname>Konrad</firstname><surname>Hinsen</surname>
    <affiliation>
      <orgname>CNRS</orgname>
      <orgdiv>Centre de Biophysique Mol&eacute;culaire</orgdiv>
      <address>
        <street>Rue Charles Sadron</street>
        <postcode>45071</postcode><city>Orl&eacute;ans</city>
        <postcode>Cedex 2</postcode>
        <country>France</country>
        <email>hinsen@cnrs-orleans.fr</email>
      </address>
    </affiliation>
  </author>
  <copyright>
    <year>1999-2002</year>
    <holder>Konrad Hinsen</holder>
  </copyright>
</bookinfo>

<preface id="introduction">
<title>Introduction</title>

<para>ScientificPython is a collection of Python modules that are
useful for scientific computing. Most modules are rather general,
others belong to specific domains and will be of interest to only a
small number of users (e.g. the module Scientific.IO.PDB). Almost all
modules make extensive use of Numerical Python (NumPy), which must be
installed prior to Scientific Python. Python 1.5 or later is also
required, Scientific.BSP requires 2.1 or later. For more information
about Numerical Python and about other packages for scientific
computing, see the
<ulink url="http://www.python.org/topics/scicomp/">Topic Guide
"Scientific Computing"</ulink> on the Python home page.
</para>

<para>This manual describes version 2.4 of ScientificPython. The 2.x
versions are completely revised and <emphasis>not</emphasis>
compatible with earlier releases. The major difference is the
introduction of a package structure; all modules are now submodules of
the top-level module Scientific. The package structure should prevent
name clashes with other modules, which have occurred in the past (e.g.
the module PDB was indistinguishable from the module pdb in the Python
standard library on operating systems without case distinction in
filenames).
</para>

<para>ScientificPython 2.x can coexist with an 1.x version, as all
module names are different. However, the availability of both versions
in parallel makes it difficult to verify that code has been fully
ported to use the new one.
</para>
</preface>

<chapter>
<title>Installation</title>

<para>ScientificPython uses the Python distutils package for
compilation and installation. The distutils is part of the
Python standard library as of Python 1.6. If you use Python 1.5,
you must download and install distutils before installing
ScientificPython.
</para>

<para>On standard Unix systems, installation requires only
two simple steps:
<programlisting role="shell">
python setup.py build
python setup.py install
</programlisting>
The second command installs ScientificPython in the Python library
directory tree, which requires root priviledges with most installations.
There are various options for installing ScientificPython in other
places, see the distutils documentation for details or type
<programlisting role="shell">
python setup.py install --help
</programlisting>
for a summary.
</para>

<para>ScientificPython contains two optional interfaces to
parallelization libraries, MPI and BSPlib. If you want to install any
of them, the corresponding parallelization library must be installed
first. Then change to directory Src/MPI (for the MPI library) or
Src/BSPlib (for BSPlib) and type
<programlisting role="shell">
python compile.py
</programlisting>
This produces an executable mpipython (for MPI) or bsppython (for BSPlib),
which should be copied to any directory on your shell's search path.
On most systems, /usr/local/bin is a suitable location. To run programs
that use MPI, BSPlib, or a higher-level library building on them
(such as the module Scientific.BSP), you must always use one of these
executables instead of the standard Python interpreter. The MPI and
BSPlib directories also include short shell scripts that run an interactive
parallel interpreter. These scripts are called impipython and ibsppython,
respectively, and should also be placed into a directory on the shell
search path. The impipython script may need editing to adapt file paths
to your MPI and Python installations.
</para>

<para>For installation on non-Unix systems, see the distutils
documentation.
</para>

</chapter>

<!-- &Modules; -->

<!-- Generated by pythondoc.DocBookFormatter 0.6 -->

<chapter id="module_reference" xreflabel="Module Reference">
<title>Reference for Module Scientific</title>

<sect1 id="Module:Scientific.BSP" xreflabel="Scientific.BSP">
<title>Module Scientific.BSP</title>

<para>This module contains high-level parallelization constructs
based on the Bulk Synchronous Parallel (BSP) model.</para>
<para>Parallelization requires a low-level communications library, which can
be either BSPlib or MPI. Programs must be run with the bsppython or
mpipython executables in order to use several processors. When run
with a standard Python interpreter, only one processor is available.</para>
<para>A warning about object identity: when a communication operation
transmits a Python object to the same processor, the object in the
return list can either be the sent object or a copy of it. Application
programs thus should not make any assumptions about received objects
being different from sent objects.
</para>
<classdescription role="Python" id="Class:Scientific.BSP.ParValue" xreflabel="Scientific.BSP.ParValue">
<classdef><class>ParValue</class><classinfo>Global data</classinfo></classdef>
<para>ParValue instances are created internally, but are not meant to be
created directly by application programs. Use the subclasses instead.</para>
<para>ParValue objects (and those of subclasses) implement the standard
arithmetic and comparison operations. They also support attribute
requests which are passed on to the local values; the return
values are ParValue objects. ParValue objects can also be called
if their local values are callable.
</para>
<methoddescription><methoddef><method>put</method></methoddef>
<paramdef><parameter>pid_list</parameter></paramdef>
<para>Sends the local data to all processors in <parameter>pid_list</parameter> (a global
object). Returns a ParValue object whose local value is a list of
all the data received from other processors. The order of the
data in that list is not defined.
</para>
</methoddescription>
<methoddescription><methoddef><method>get</method></methoddef>
<paramdef><parameter>pid_list</parameter></paramdef>
<para>Requests the local data from all processors in <parameter>pid_list</parameter> (a global
object). Returns a ParValue object whose local value is a list of
all the data received from other processors. The order of the
data in that list is not defined.
</para>
</methoddescription>
<methoddescription><methoddef><method>broadcast</method></methoddef>
<paramdef><parameter>from_pid</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Transmits the local data on processor <parameter>from_pid</parameter> to all
processors. Returns a ParValue object.
</para>
</methoddescription>
<methoddescription><methoddef><method>fullExchange</method></methoddef>
<void/><para>Transmits the local data of each processor to all other
processors. Returns a ParValue object.
</para>
</methoddescription>
<methoddescription><methoddef><method>reduce</method></methoddef>
<paramdef><parameter>operator</parameter></paramdef>
<paramdef><parameter>zero</parameter></paramdef>
<para>Performs a reduction with <parameter>operator</parameter> over the local values
of all processors using <parameter>zero</parameter> as initial value. The result
is a ParValue object with the reduction result on processor 0
and <parameter>zero</parameter> on all other processors.
</para>
</methoddescription>
<methoddescription><methoddef><method>accumulate</method></methoddef>
<paramdef><parameter>operator</parameter></paramdef>
<paramdef><parameter>zero</parameter></paramdef>
<para>Performs an accumulation with <parameter>operator</parameter> over the local values
of all processors using <parameter>zero</parameter> as initial value. The result
is a ParValue object whose local value on each processor is the
reduction of the values from all processors with lower or equal
number.
</para>
</methoddescription>
<methoddescription><methoddef><method>alltrue</method></methoddef>
<void/><para>Returns 1 (local value) if the local values on all
processors are true.
</para>
</methoddescription>
<methoddescription><methoddef><method>anytrue</method></methoddef>
<void/><para>Returns 1 (local value) if at least one of the local values on all
processors is true.
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParConstant" xreflabel="Scientific.BSP.ParConstant">
<classdef><class>ParConstant</class><classinfo>Global constant</classinfo></classdef>
<para>A subclass of ParValue.</para>
<para>Constructor: ParConstant(<parameter>value</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>value</parameter></term>
<listitem><para>
any local or global object
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParData" xreflabel="Scientific.BSP.ParData">
<classdef><class>ParData</class><classinfo>Global data</classinfo></classdef>
<para>A subclass of ParValue</para>
<para>Constructor: ParData(<parameter>function</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>function</parameter></term>
<listitem><para>
a function of two arguments (processor number and
              number of processors in the machine) whose return
              value becomes the local value of the global object.
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParSequence" xreflabel="Scientific.BSP.ParSequence">
<classdef><class>ParSequence</class><classinfo>Global distributed sequence</classinfo></classdef>
<para>A subclass of ParValue.</para>
<para>Constructor: ParSequence(<parameter>full_sequence</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>full_sequence</parameter></term>
<listitem><para>
any indexable and sliceable Python sequence</para></listitem></varlistentry>
</variablelist></para>
<para>The local value of a ParSequence object is a slice of <parameter>full_sequence</parameter>,
which is constructed such that the concatenation of the local values
of all processors equals <parameter>full_sequence</parameter>.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParMessages" xreflabel="Scientific.BSP.ParMessages">
<classdef><class>ParMessages</class><classinfo>Global message list</classinfo></classdef>
<para>A subclass of ParValue.</para>
<para>Constructor: ParMessage(<parameter>messages</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>messages</parameter></term>
<listitem><para>
a global object whose local value is a list of
              (pid, data) pairs.
</para></listitem></varlistentry>
</variablelist></para>
<methoddescription><methoddef><method>processorIds</method></methoddef>
<void/><para>Returns a ParValue object whose local value is a list of
all processor Ids referenced in a message.
</para>
</methoddescription>
<methoddescription><methoddef><method>data</method></methoddef>
<void/><para>Returns a ParValue object whose local value is a list of
all data items in the messages.
</para>
</methoddescription>
<methoddescription><methoddef><method>exchange</method></methoddef>
<void/><para>Sends all the messages and returns a ParValue object
containing the received messages.
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParTuple" xreflabel="Scientific.BSP.ParTuple">
<classdef><class>ParTuple</class><classinfo>Global data tuple</classinfo></classdef>
<para>A subclass of ParValue.</para>
<para>Constructor: ParTuple(<parameter>x1</parameter>, <parameter>x2</parameter>, ...)</para>
<para><variablelist>
<varlistentry><term><parameter>x1</parameter>, <parameter>x2</parameter>, ...</term>
<listitem><para>
global objects</para></listitem></varlistentry>
</variablelist></para>
<para>ParTuple objects are used to speed up communication when many data
items need to be sent to the same processors. The construct
a, b, c = ParTuple(a, b, c).put(pids) is logically equivalent to
a = a.put(pids); b = b.put(pids); c = c.put(pids) but more efficient.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParAccumulator" xreflabel="Scientific.BSP.ParAccumulator">
<classdef><class>ParAccumulator</class><classinfo>Global accumulator</classinfo></classdef>
<para>A subclass of ParValue.</para>
<para>Constructor: ParAccumulator(<parameter>operator</parameter>, <parameter>zero</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>operator</parameter></term>
<listitem><para>
a local function taking two arguments and returning
              one argument of the same type.</para></listitem></varlistentry>
<varlistentry><term><parameter>zero</parameter></term>
<listitem><para>
an initial value for reduction.</para></listitem></varlistentry>
</variablelist></para>
<para>ParAccumulator objects are used to perform iterative reduction
operations in loops. The initial local value is <parameter>zero</parameter>, which is
modified by subsequent calls to the method addValue.
</para>
<methoddescription><methoddef><method>addValue</method></methoddef>
<paramdef><parameter>value</parameter></paramdef>
<para>Replaces the internal value of the accumulator by
internal_value = operator(internal_value, value).
</para>
</methoddescription>
<methoddescription><methoddef><method>calculateTotal</method></methoddef>
<void/><para>Performs a reduction operation over the current local
values on all processors. Returns a ParValue object.
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParFunction" xreflabel="Scientific.BSP.ParFunction">
<classdef><class>ParFunction</class><classinfo>Global function</classinfo></classdef>
<para>A subclass of ParValue.</para>
<para>Constructor: ParFunction(<parameter>local_function</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>local_function</parameter></term>
<listitem><para>
a local function</para></listitem></varlistentry>
</variablelist></para>
<para>Global functions are called with global object arguments.
The local values of these arguments are then passed to the local
function, and the result is returned in a ParValue object.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParRootFunction" xreflabel="Scientific.BSP.ParRootFunction">
<classdef><class>ParRootFunction</class><classinfo>Asymmetric global function</classinfo></classdef>
<para>Constructor: ParRootFunction(<parameter>root_function</parameter>, <parameter>other_function</parameter>=None)</para>
<para><variablelist>
<varlistentry><term><parameter>root_function</parameter></term>
<listitem><para>
the local function for processor 0</para></listitem></varlistentry>
<varlistentry><term><parameter>other_function</parameter></term>
<listitem><para>
the local function for all other processors. The
                    default is a function that returns None.</para></listitem></varlistentry>
</variablelist></para>
<para>Global functions are called with global object arguments.
The local values of these arguments are then passed to the local
function, and the result is returned in a ParValue object.</para>
<para>A ParRootFunction differs from a ParFunction in that it uses a different
local function for processor 0 than for the other processors.
ParRootFunction objects are commonly used for I/O operations.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParIterator" xreflabel="Scientific.BSP.ParIterator">
<classdef><class>ParIterator</class><classinfo>Parallel iterator</classinfo></classdef>
<para>Constructor: ParIterator(<parameter>global_sequence</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>global_sequence</parameter></term>
<listitem><para>
a global object representing a distributed
                     sequence</para></listitem></varlistentry>
</variablelist></para>
<para>A ParIterator is used to loop element by element over a distributed
sequence. At each iteration, the returned item (a global object)
contains different elements of the distributed sequence.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParIndexIterator" xreflabel="Scientific.BSP.ParIndexIterator">
<classdef><class>ParIndexIterator</class><classinfo>Parallel index iterator</classinfo></classdef>
<para>Constructor: ParIndexIterator(<parameter>global_sequence</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>global_sequence</parameter></term>
<listitem><para>
a global object representing a distributed
                     sequence</para></listitem></varlistentry>
</variablelist></para>
<para>A ParIndexIterator is used to loop index by index over one or more
distributed sequences. At each iteration, the returned item (a
global index object) contains indices of different elements of the
distributed sequence(s). The index objects can be used to index
any ParValue object whose local value is a sequence object.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParClass" xreflabel="Scientific.BSP.ParClass">
<classdef><class>ParClass</class><classinfo>Global class</classinfo></classdef>
<para>Constructor: ParClass(<parameter>local_class</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>local_class</parameter></term>
<listitem><para>
a local class</para></listitem></varlistentry>
</variablelist></para>
<para>Global classes are needed to construct global objects that
have more functionalities than offered by the ParValue class hierarchy.
When an instance of a global class is generated, each processor
generates an instance of <parameter>local_class</parameter> that becomes the local value
of the new global object. Attribute requests and method calls
are passed through to the local objects and the results are
assembled into global objects (ParValue or ParFunction). The arguments
to methods of a global class must be global objects, the local class
methods are then called with the corresponding local values.</para>
<para>The local objects are initialized via the special method
__parinit__ instead of the usual __init__. This method is called
with two special arguments (processor number and total number of
processors) followed by the local values of the arguments to the
global object initialization call.</para>
<para>The local classes must inherit from the base class ParBase (see below),
which also provides  communication routines.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.BSP.ParBase" xreflabel="Scientific.BSP.ParBase">
<classdef><class>ParBase</class><classinfo>Distributed data base class</classinfo></classdef>
<para>Local classes that are to be used in global classes
must inherit from this class.
</para>
<methoddescription><methoddef><method>put</method></methoddef>
<paramdef><parameter>data</parameter></paramdef>
<paramdef><parameter>pid_list</parameter></paramdef>
<para>Send <parameter>data</parameter> to all processors in <parameter>pid_list</parameter>. Returns the list
of received objects.
</para>
</methoddescription>
<methoddescription><methoddef><method>get</method></methoddef>
<paramdef><parameter>data</parameter></paramdef>
<paramdef><parameter>pid_list</parameter></paramdef>
<para>Requests the local values of <parameter>data</parameter> of all processors in <parameter>pid_list</parameter>.
Returns the list of received objects.
</para>
</methoddescription>
<methoddescription><methoddef><method>broadcast</method></methoddef>
<paramdef><parameter>data</parameter></paramdef>
<paramdef><parameter>from_pid</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Sends the local value of <parameter>data</parameter> on processor <parameter>from_pid</parameter> to
all processors. Returns the list of received objects.
</para>
</methoddescription>
<methoddescription><methoddef><method>exchangeMessages</method></methoddef>
<paramdef><parameter>message_list</parameter></paramdef>
<para>Sends the (pid, data) messages in <parameter>message_list</parameter> to the destination
processors. Returns the list of incoming data.
</para>
</methoddescription>
</classdescription>

<sect2 id="Module:Scientific.BSP.Console" xreflabel="Scientific.BSP.Console">
<title>Module Scientific.BSP.Console</title>

</sect2>

<sect2 id="Module:Scientific.BSP.IO" xreflabel="Scientific.BSP.IO">
<title>Module Scientific.BSP.IO</title>

<para>This module provides parallel acces to netCDF files. One netCDF dimension
is defined for splitting the data among processors such that each processor
is responsible for one slice of the file along that dimension.</para>
<para>Since netCDF files can be very big, the distribution algorithm gives
priority to memory efficiency over CPU time efficiency. The processor
that handles the file treats only one slice per superstep, which means
that at no time more than one slice must be stored in any processor.
</para>
<classdescription role="Python" id="Class:Scientific.BSP.IO._ParNetCDFFile" xreflabel="Scientific.BSP.IO._ParNetCDFFile">
<classdef><class>_ParNetCDFFile</class><classinfo>Distributed netCDF file</classinfo></classdef>
<para>Constructor: ParNetCDFFile(<parameter>filename</parameter>, <parameter>split_dimension</parameter>, <parameter>mode</parameter>=<literal role="Python">r</literal>,
                           <parameter>local_access</parameter> = 0)</para>
<para><variablelist>
<varlistentry><term><parameter>filename</parameter></term>
<listitem><para>
the name of the netCDF file</para></listitem></varlistentry>
<varlistentry><term><parameter>split_dimension</parameter></term>
<listitem><para>
the name of the dimension along which the data
                     is distributed over the processors</para></listitem></varlistentry>
<varlistentry><term><parameter>mode</parameter></term>
<listitem><para>
read (<literal role="Python">r</literal>), write (<literal role="Python">w</literal>), or append (<literal role="Python">a</literal>). Default is <literal role="Python">r</literal>.</para></listitem></varlistentry>
<varlistentry><term><parameter>local_access</parameter></term>
<listitem><para>
if 0 (default), processor 0 is the only one to access
                  the file, all others communicate with processor 0. If
                  1 (only for reading), each processor accesses the
                  file directly. In the latter case, the file must be
                  accessible on all processors under the same name.
                  A third mode is <literal role="Python">auto</literal>, which uses some heuristics
                  to decide if the file is accessible everywhere:
                  it checks for existence of the file, then compares
                  the size on all processors, and finally verifies
                  that the same variables exist everywhere, with
                  identical names, types, and sizes.</para></listitem></varlistentry>
</variablelist></para>
<para>A ParNetCDFFile object acts as much as possible like a NetCDFFile object.
Variables become ParNetCDFVariable objects, which behave like
distributed sequences. Variables that use the dimension named by
<parameter>split_dimension</parameter> are automatically distributed among the processors
such that each treats only one slice of the whole file.
</para>
</classdescription>

</sect2>

</sect1>

<sect1 id="Module:Scientific.DictWithDefault" xreflabel="Scientific.DictWithDefault">
<title>Module Scientific.DictWithDefault</title>

<classdescription role="Python" id="Class:Scientific.DictWithDefault.DictWithDefault" xreflabel="Scientific.DictWithDefault.DictWithDefault">
<classdef><class>DictWithDefault</class><classinfo>Dictionary with default values</classinfo></classdef>
<para>Constructor:  DictWithDefault(<parameter>default</parameter>)</para>
<para>Instances of this class act like standard Python dictionaries,
except that they return a <emphasis>copy</emphasis> of <parameter>default</parameter> for a key that
has no associated value.
</para>
</classdescription>

</sect1>

<sect1 id="Module:Scientific.Functions" xreflabel="Scientific.Functions">
<title>Module Scientific.Functions</title>

<sect2 id="Module:Scientific.Functions.Derivatives" xreflabel="Scientific.Functions.Derivatives">
<title>Module Scientific.Functions.Derivatives</title>

<para>This module provides automatic differentiation for functions with
any number of variables up to any order. An instance of the class
DerivVar represents the value of a function and the values of its partial
derivatives with respect to a list of variables. All common
mathematical operations and functions are available for these numbers.
There is no restriction on the type of the numbers fed into the
code; it works for real and complex numbers as well as for
any Python type that implements the necessary operations.</para>
<para>If only first-order derivatives are required, the module
FirstDerivatives should be used. It is compatible to this
one, but significantly faster.</para>
<example><title>Example:</title><para>  <literal role="Python">print sin(DerivVar(2))</literal></para>
<para>  produces the output</para>
<para>  <literal role="Python">(0.909297426826, [-0.416146836547])</literal></para>
</example>
<para>The first number is the value of sin(2); the number in the following
list is the value of the derivative of sin(x) at x=2, i.e. cos(2).</para>
<para>When there is more than one variable, DerivVar must be called with
an integer second argument that specifies the number of the variable.</para>
<example><title>Example:</title><programlisting role="Python">
x = DerivVar(7., 0)
y = DerivVar(42., 1)
z = DerivVar(pi, 2)
print (sqrt(pow(x,2)+pow(y,2)+pow(z,2)))</programlisting><para>  produces the output</para>
<programlisting role="Python">
(42.6950770511, [0.163953328662, 0.98371997197, 0.0735820818365])</programlisting></example>
<para>The numbers in the list are the partial derivatives with respect
to x, y, and z, respectively.</para>
<para>Higher-order derivatives are requested with an optional third
argument to DerivVar.</para>
<example><title>Example:</title><programlisting role="Python">
x = DerivVar(3., 0, 3)
y = DerivVar(5., 1, 3)
print sqrt(x*y)</programlisting><para>  produces the output</para>
<programlisting role="Python">
(3.87298334621,
    [0.645497224368, 0.387298334621],
      [[-0.107582870728, 0.0645497224368],
        [0.0645497224368, -0.0387298334621]],
          [[[0.053791435364, -0.0107582870728],
            [-0.0107582870728, -0.00645497224368]],
           [[-0.0107582870728, -0.00645497224368],
            [-0.00645497224368, 0.0116189500386]]])</programlisting></example>
<example><title>The individual orders can be extracted by indexing:</title><programlisting role="Python">
print sqrt(x*y)[0]
3.87298334621
print sqrt(x*y)[1]
[0.645497224368, 0.387298334621]</programlisting></example>
<para>An n-th order derivative is represented by a nested list of
depth n.</para>
<para>When variables with different differentiation orders are mixed,
the result has the lower one of the two orders. An exception are
zeroth-order variables, which are treated as constants.</para>
<para>Caution: Higher-order derivatives are implemented by recursively
using DerivVars to represent derivatives. This makes the code
very slow for high orders.</para>
<example><title>Note: It doesn't make sense to use multiple DerivVar objects with
different values for the same variable index in one calculation, but
there is no check for this. I.e.</title><programlisting role="Python">
print DerivVar(3, 0)+DerivVar(5, 0)</programlisting><para>  produces</para>
<programlisting role="Python">
(8, [2])</programlisting></example>
<para>but this result is meaningless.
</para>
<classdescription role="Python" id="Class:Scientific.Functions.Derivatives.DerivVar" xreflabel="Scientific.Functions.Derivatives.DerivVar">
<classdef><class>DerivVar</class><classinfo>Variable with derivatives</classinfo></classdef>
<para>Constructor: DerivVar(<parameter>value</parameter>, <parameter>index</parameter> = 0, <parameter>order</parameter> = 1)</para>
<para><variablelist>
<varlistentry><term><parameter>value</parameter></term>
<listitem><para>
the numerical value of the variable</para></listitem></varlistentry>
<varlistentry><term><parameter>index</parameter></term>
<listitem><para>
the variable index (an integer), which serves to
           distinguish between variables and as an index for
           the derivative lists. Each explicitly created
           instance of DerivVar must have a unique index.</para></listitem></varlistentry>
<varlistentry><term><parameter>order</parameter></term>
<listitem><para>
the derivative order</para></listitem></varlistentry>
</variablelist></para>
<para>Indexing with an integer yields the derivatives of the corresponding
order.
</para>
<methoddescription><methoddef><method>toOrder</method></methoddef>
<paramdef><parameter>order</parameter></paramdef>
<para>Returns a DerivVar object with a lower derivative order.</para>
</methoddescription>
</classdescription>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Functions.Derivatives.isDerivVar" xreflabel="Scientific.Functions.Derivatives.isDerivVar" role="Python"><funcprototype><funcdef><function>isDerivVar</function></funcdef>
<paramdef><parameter>x</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns 1 if <parameter>x</parameter> is a DerivVar object.</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Functions.Derivatives.DerivVector" xreflabel="Scientific.Functions.Derivatives.DerivVector" role="Python"><funcprototype><funcdef><function>DerivVector</function></funcdef>
<paramdef><parameter>x</parameter></paramdef>
<paramdef><parameter>y</parameter></paramdef>
<paramdef><parameter>z</parameter></paramdef>
<paramdef><parameter>index</parameter><defaultvalue>0</defaultvalue></paramdef>
<paramdef><parameter>order</parameter><defaultvalue>1</defaultvalue></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns a vector whose components are DerivVar objects.</para>
<para><variablelist>
<varlistentry><term><parameter>x</parameter>, <parameter>y</parameter>, <parameter>z</parameter></term>
<listitem><para>
vector components (numbers)</para></listitem></varlistentry>
<varlistentry><term><parameter>index</parameter></term>
<listitem><para>
the DerivVar index for the x component. The y and z
           components receive consecutive indices.</para></listitem></varlistentry>
<varlistentry><term><parameter>order</parameter></term>
<listitem><para>
the derivative order
</para></listitem></varlistentry>
</variablelist></para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.Functions.FindRoot" xreflabel="Scientific.Functions.FindRoot">
<title>Module Scientific.Functions.FindRoot</title>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Functions.FindRoot.newtonRaphson" xreflabel="Scientific.Functions.FindRoot.newtonRaphson" role="Python"><funcprototype><funcdef><function>newtonRaphson</function></funcdef>
<paramdef><parameter>function</parameter></paramdef>
<paramdef><parameter>lox</parameter></paramdef>
<paramdef><parameter>hix</parameter></paramdef>
<paramdef><parameter>xacc</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Finds the root of <parameter>function</parameter> which is bracketed by values
<parameter>lox</parameter> and <parameter>hix</parameter> to an accuracy of +/- <parameter>xacc</parameter>. The algorithm
used is a safe version of Newton-Raphson (see page 366 of NR in
C, 2ed). <parameter>function</parameter> must be a function of one variable, and may
only use operations defined for the DerivVar objects in the
module FirstDerivatives.</para>
<example><title>Example:</title><programlisting role="Python">
from Scientific.Functions.FindRoot import newtonRaphson
from math import pi
def func(x):
    return (2*x*cos(x) - sin(x))*cos(x) - x + pi/4.0
newtonRaphson(func, 0.0, 1.0, 1.0e-12)</programlisting><para>  yields <literal role="Python">0.952847864655</literal>.
</para>
</example>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.Functions.FirstDerivatives" xreflabel="Scientific.Functions.FirstDerivatives">
<title>Module Scientific.Functions.FirstDerivatives</title>

<para>This module provides automatic differentiation for functions with
any number of variables. Instances of the class DerivVar represent the
values of a function and its partial derivatives with respect to a
list of variables. All common mathematical operations and functions
are available for these numbers.  There is no restriction on the type
of the numbers fed into the code; it works for real and complex
numbers as well as for any Python type that implements the necessary
operations.</para>
<para>This module is as far as possible compatible with the n-th order
derivatives module Derivatives. If only first-order derivatives
are required, this module is faster than the general one.</para>
<example><title>Example:</title><programlisting role="Python">
print sin(DerivVar(2))</programlisting><para>  produces the output</para>
<programlisting role="Python">
(0.909297426826, [-0.416146836547])</programlisting></example>
<para>The first number is the value of sin(2); the number in the following
list is the value of the derivative of sin(x) at x=2, i.e. cos(2).</para>
<para>When there is more than one variable, DerivVar must be called with
an integer second argument that specifies the number of the variable.</para>
<example><title>Example:</title><programlisting role="Python">
x = DerivVar(7., 0)
y = DerivVar(42., 1)
z = DerivVar(pi, 2)
print (sqrt(pow(x,2)+pow(y,2)+pow(z,2)))</programlisting><para>  produces the output</para>
<programlisting role="Python">
(42.6950770511, [0.163953328662, 0.98371997197, 0.0735820818365])</programlisting></example>
<para>The numbers in the list are the partial derivatives with respect
to x, y, and z, respectively.</para>
<example><title>Note: It doesn't make sense to use DerivVar with different values
for the same variable index in one calculation, but there is
no check for this. I.e.</title><programlisting role="Python">
print DerivVar(3, 0)+DerivVar(5, 0)</programlisting><para>  produces</para>
<programlisting role="Python">
(8, [2])</programlisting></example>
<para>but this result is meaningless.
</para>
<classdescription role="Python" id="Class:Scientific.Functions.FirstDerivatives.DerivVar" xreflabel="Scientific.Functions.FirstDerivatives.DerivVar">
<classdef><class>DerivVar</class><classinfo>Variable with derivatives</classinfo></classdef>
<para>Constructor: DerivVar(<parameter>value</parameter>, <parameter>index</parameter> = 0)</para>
<para><variablelist>
<varlistentry><term><parameter>value</parameter></term>
<listitem><para>
the numerical value of the variable</para></listitem></varlistentry>
<varlistentry><term><parameter>index</parameter></term>
<listitem><para>
the variable index (an integer), which serves to
           distinguish between variables and as an index for
           the derivative lists. Each explicitly created
           instance of DerivVar must have a unique index.</para></listitem></varlistentry>
</variablelist></para>
<para>Indexing with an integer yields the derivatives of the corresponding
order.
</para>
</classdescription>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Functions.FirstDerivatives.isDerivVar" xreflabel="Scientific.Functions.FirstDerivatives.isDerivVar" role="Python"><funcprototype><funcdef><function>isDerivVar</function></funcdef>
<paramdef><parameter>x</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns 1 if <parameter>x</parameter> is a DerivVar object.</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Functions.FirstDerivatives.DerivVector" xreflabel="Scientific.Functions.FirstDerivatives.DerivVector" role="Python"><funcprototype><funcdef><function>DerivVector</function></funcdef>
<paramdef><parameter>x</parameter></paramdef>
<paramdef><parameter>y</parameter></paramdef>
<paramdef><parameter>z</parameter></paramdef>
<paramdef><parameter>index</parameter><defaultvalue>0</defaultvalue></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns a vector whose components are DerivVar objects.</para>
<para><variablelist>
<varlistentry><term><parameter>x</parameter>, <parameter>y</parameter>, <parameter>z</parameter></term>
<listitem><para>
vector components (numbers)</para></listitem></varlistentry>
<varlistentry><term><parameter>index</parameter></term>
<listitem><para>
the DerivVar index for the x component. The y and z
           components receive consecutive indices.
</para></listitem></varlistentry>
</variablelist></para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.Functions.Interpolation" xreflabel="Scientific.Functions.Interpolation">
<title>Module Scientific.Functions.Interpolation</title>

<classdescription role="Python" id="Class:Scientific.Functions.Interpolation.InterpolatingFunction" xreflabel="Scientific.Functions.Interpolation.InterpolatingFunction">
<classdef><class>InterpolatingFunction</class><classinfo>Function defined by values on a grid using interpolation</classinfo></classdef>
<para>An interpolating function of n variables with m-dimensional values
is defined by an (n+m)-dimensional array of values and n
one-dimensional arrays that define the variables values
corresponding to the grid points. The grid does not have to be
equidistant.</para>
<para>Constructor: InterpolatingFunction(<parameter>axes</parameter>, <parameter>values</parameter>, <parameter>default</parameter>=None)</para>
<para><variablelist>
<varlistentry><term><parameter>axes</parameter></term>
<listitem><para>
a sequence of one-dimensional arrays, one for each
          variable, specifying the values of the variables at
          the grid points</para></listitem></varlistentry>
<varlistentry><term><parameter>values</parameter></term>
<listitem><para>
an array containing the function values on the grid</para></listitem></varlistentry>
<varlistentry><term><parameter>default</parameter></term>
<listitem><para>
the value of the function outside the grid. A value
             of <literal role="Python">None</literal> means that the function is undefined outside
             the grid and that any attempt to evaluate it there
             yields an exception.</para></listitem></varlistentry>
</variablelist></para>
<para>Evaluation: <literal role="Python">function(x1, x2, ...)</literal> yields the function value
            obtained by linear interpolation.</para>
<para>Indexing: all array indexing operations except for the
          NexAxis operator are supported.
</para>
<methoddescription><methoddef><method>selectInterval</method></methoddef>
<paramdef><parameter>first</parameter></paramdef>
<paramdef><parameter>last</parameter></paramdef>
<paramdef><parameter>variable</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Returns a new InterpolatingFunction whose grid is restricted
to the interval from <parameter>first</parameter> to <parameter>last</parameter> along the variable
whose number is <parameter>variable</parameter>.
</para>
</methoddescription>
<methoddescription><methoddef><method>derivative</method></methoddef>
<paramdef><parameter>variable</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Returns a new InterpolatingFunction describing the derivative
with respect to <parameter>variable</parameter> (an integer).
</para>
</methoddescription>
<methoddescription><methoddef><method>integral</method></methoddef>
<paramdef><parameter>variable</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Returns a new InterpolatingFunction describing the integral
with respect to <parameter>variable</parameter> (an integer). The integration constant
is defined in such a way that the value of the integral at the
first grid point along <parameter>variable</parameter> is zero.</para>
</methoddescription>
<methoddescription><methoddef><method>definiteIntegral</method></methoddef>
<paramdef><parameter>variable</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Returns a new InterpolatingFunction describing the definite integral
with respect to <parameter>variable</parameter> (an integer). The integration constant
is defined in such a way that the value of the integral at the
first grid point along <parameter>variable</parameter> is zero. In the case of a
function of one variable, the definite integral is a number.</para>
</methoddescription>
<methoddescription><methoddef><method>fitPolynomial</method></methoddef>
<paramdef><parameter>order</parameter></paramdef>
<para>Returns a polynomial of <parameter>order</parameter> with parameters obtained from
a least-squares fit to the grid values.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Functions.Interpolation.NetCDFInterpolatingFunction" xreflabel="Scientific.Functions.Interpolation.NetCDFInterpolatingFunction">
<classdef><class>NetCDFInterpolatingFunction</class><classinfo>Function defined by values on a grid in a netCDF file</classinfo></classdef>
<para>A subclass of InterpolatingFunction.</para>
<para>Constructor: NetCDFInterpolatingFunction(<parameter>filename</parameter>, <parameter>axesnames</parameter>,
                                         <parameter>variablename</parameter>,
                                         <parameter>default</parameter>=None)</para>
<para><variablelist>
<varlistentry><term><parameter>filename</parameter></term>
<listitem><para>
the name of the netCDF file</para></listitem></varlistentry>
<varlistentry><term><parameter>axesnames</parameter></term>
<listitem><para>
the names of the netCDF variables that contain the
               axes information</para></listitem></varlistentry>
<varlistentry><term><parameter>variablename</parameter></term>
<listitem><para>
the name of the netCDF variable that contains
                  the data values</para></listitem></varlistentry>
<varlistentry><term><parameter>default</parameter></term>
<listitem><para>
the value of the function outside the grid. A value
             of <literal role="Python">None</literal> means that the function is undefined outside
             the grid and that any attempt to evaluate it there
             yields an exception.</para></listitem></varlistentry>
</variablelist></para>
<para>Evaluation: <literal role="Python">function(x1, x2, ...)</literal> yields the function value
            obtained by linear interpolation.
</para>
</classdescription>

</sect2>

<sect2 id="Module:Scientific.Functions.LeastSquares" xreflabel="Scientific.Functions.LeastSquares">
<title>Module Scientific.Functions.LeastSquares</title>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Functions.LeastSquares.leastSquaresFit" xreflabel="Scientific.Functions.LeastSquares.leastSquaresFit" role="Python"><funcprototype><funcdef><function>leastSquaresFit</function></funcdef>
<paramdef><parameter>model</parameter></paramdef>
<paramdef><parameter>parameters</parameter></paramdef>
<paramdef><parameter>data</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>General non-linear least-squares fit using the
Levenberg-Marquardt algorithm and automatic derivatives.</para>
<para>The parameter <parameter>model</parameter> specifies the function to be fitted. It will be
called with two parameters: the first is a tuple containing all fit
parameters, and the second is the first element of a data point (see
below). The return value must be a number.  Since automatic
differentiation is used to obtain the derivatives with respect to the
parameters, the function may only use the mathematical functions known
to the module FirstDerivatives.</para>
<para>The parameter <parameter>parameter</parameter> is a tuple of initial values for the
fit parameters.</para>
<para>The parameter <parameter>data</parameter> is a list of data points to which the model
is to be fitted. Each data point is a tuple of length two or
three. Its first element specifies the independent variables
of the model. It is passed to the model function as its first
parameter, but not used in any other way. The second element
of each data point tuple is the number that the return value
of the model function is supposed to match as well as possible.
The third element (which defaults to 1.) is the statistical
variance of the data point, i.e. the inverse of its statistical
weight in the fitting procedure.</para>
<para>The function returns a list containing the optimal parameter values
and the chi-squared value describing the quality of the fit.
</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Functions.LeastSquares.polynomialLeastSquaresFit" xreflabel="Scientific.Functions.LeastSquares.polynomialLeastSquaresFit" role="Python"><funcprototype><funcdef><function>polynomialLeastSquaresFit</function></funcdef>
<paramdef><parameter>parameters</parameter></paramdef>
<paramdef><parameter>data</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Least-squares fit to a polynomial whose order is defined by
the number of parameter values.</para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.Functions.Polynomial" xreflabel="Scientific.Functions.Polynomial">
<title>Module Scientific.Functions.Polynomial</title>

<classdescription role="Python" id="Class:Scientific.Functions.Polynomial.Polynomial" xreflabel="Scientific.Functions.Polynomial.Polynomial">
<classdef><class>Polynomial</class><classinfo>Multivariate polynomial</classinfo></classdef>
<para>Instances of this class represent polynomials of any order and
in any number of variables. They can be evaluated like functions.</para>
<para>Constructor: Polynomial(<parameter>coefficients</parameter>), where <parameter>coefficients</parameter> is
an array whose dimension defines the number of variables and whose
length along each axis defines the order in the corresponding
variable. The coefficients are ordered according to increasing
powers, i.e.\ [1., 2.] stands for 1.+2.*x.
</para>
<methoddescription><methoddef><method>derivative</method></methoddef>
<paramdef><parameter>variable</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Returns the derivative with respect to <parameter>variable</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>integral</method></methoddef>
<paramdef><parameter>variable</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Returns the indefinite integral with respect to <parameter>variable</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>zeros</method></methoddef>
<void/><para>Returns an array containing the zeros (one variable only).</para>
</methoddescription>
</classdescription>

</sect2>

<sect2 id="Module:Scientific.Functions.Rational" xreflabel="Scientific.Functions.Rational">
<title>Module Scientific.Functions.Rational</title>

<classdescription role="Python" id="Class:Scientific.Functions.Rational.RationalFunction" xreflabel="Scientific.Functions.Rational.RationalFunction">
<classdef><class>RationalFunction</class><classinfo>Rational Function</classinfo></classdef>
<para>Instances of this class represent rational functions
in a single variable. They can be evaluated like functions.</para>
<para>Constructor: RationalFunction(<parameter>numerator</parameter>, <parameter>denominator</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>numerator</parameter>, <parameter>denominator</parameter></term>
<listitem><para>
polynomials or sequences of numbers that
                              represent the polynomial coefficients</para></listitem></varlistentry>
</variablelist></para>
<para>Rational functions support addition, subtraction, multiplication,
and division.
</para>
<methoddescription><methoddef><method>divide</method></methoddef>
<paramdef><parameter>shift</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Returns a polynomial and a rational function such that the
sum of the two is equal to the original rational function. The
returned rational function's numerator is of lower order than
its denominator.</para>
<para>The argument <parameter>shift</parameter> (default: 0) specifies a positive integer
power of the independent variable by which the numerator
is multiplied prior to division.
</para>
</methoddescription>
<methoddescription><methoddef><method>zeros</method></methoddef>
<void/><para>Returns an array containing the zeros.</para>
</methoddescription>
<methoddescription><methoddef><method>poles</method></methoddef>
<void/><para>Returns an array containing the poles.</para>
</methoddescription>
</classdescription>

</sect2>

<sect2 id="Module:Scientific.Functions.Romberg" xreflabel="Scientific.Functions.Romberg">
<title>Module Scientific.Functions.Romberg</title>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Functions.Romberg.trapezoid" xreflabel="Scientific.Functions.Romberg.trapezoid" role="Python"><funcprototype><funcdef><function>trapezoid</function></funcdef>
<paramdef><parameter>function</parameter></paramdef>
<paramdef><parameter>interval</parameter></paramdef>
<paramdef><parameter>numtraps</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns the integral of <parameter>function</parameter> (a function of one variable)
over <parameter>interval</parameter> (a sequence of length two containing the lower and
upper limit of the integration interval), calculated using the
trapezoidal rule using <parameter>numtraps</parameter> trapezoids.</para>
<example><title>Example:</title><programlisting role="Python">
from Scientific.Functions.Romberg import romberg
from Numeric import pi
romberg(tan, (0.0, pi/3.0))</programlisting><para>  yields <literal role="Python">0.693147180562</literal>
</para>
</example>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Functions.Romberg.romberg" xreflabel="Scientific.Functions.Romberg.romberg" role="Python"><funcprototype><funcdef><function>romberg</function></funcdef>
<paramdef><parameter>function</parameter></paramdef>
<paramdef><parameter>interval</parameter></paramdef>
<paramdef><parameter>accuracy</parameter><defaultvalue>9.9999999999999995e-08</defaultvalue></paramdef>
<paramdef><parameter>show</parameter><defaultvalue>0</defaultvalue></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns the integral of <parameter>function</parameter> (a function of one variable)
over <parameter>interval</parameter> (a sequence of length two containing the lower and
upper limit of the integration interval), calculated using
Romberg integration up to the specified <parameter>accuracy</parameter>. If <parameter>show</parameter> is 1,
the triangular array of the intermediate results will be printed.</para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

</sect1>

<sect1 id="Module:Scientific.Geometry" xreflabel="Scientific.Geometry">
<title>Module Scientific.Geometry</title>

<para>This subpackage contains classes that deal with geometrical
quantities and objects. The geometrical quantities are vectors and
tensors, transformations, and quaternions as descriptions of
rotations.  There are also tensor fields, which were included here
(rather than in the subpackage Scientific.Functions) because they are
most often used in a geometric context. Finally, there are classes for
elementary geometrical objects such as spheres and planes.
</para>
<classdescription role="Python" id="Class:Scientific.Geometry.Tensor" xreflabel="Scientific.Geometry.Tensor">
<classdef><class>Tensor</class><classinfo>Tensor in 3D space</classinfo></classdef>
<para>Constructor: Tensor([[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]])</para>
<para>Tensors support the usual arithmetic operations
(<literal role="Python">t1</literal>, <literal role="Python">t2</literal>: tensors, <literal role="Python">v</literal>: vector, <literal role="Python">s</literal>: scalar): </para>
<itemizedlist>
<listitem><para>
<literal role="Python">t1+t2</literal>        (addition)
</para></listitem>
<listitem><para>
<literal role="Python">t1-t2</literal>        (subtraction)
</para></listitem>
<listitem><para>
<literal role="Python">t1*t2</literal>        (tensorial (outer) product)
</para></listitem>
<listitem><para>
<literal role="Python">t1*v</literal>         (contraction with a vector, same as t1.dot(v.asTensor()))
</para></listitem>
<listitem><para>
<literal role="Python">s*t1</literal>, <literal role="Python">t1*s</literal> (multiplication with a scalar)
</para></listitem>
<listitem><para>
<literal role="Python">t1/s</literal>         (division by a scalar)</para></listitem>
</itemizedlist>
<para>The coordinates can be extracted by indexing; a tensor of rank N
can be indexed like an array of dimension N.</para>
<para>Tensors are <emphasis>immutable</emphasis>, i.e. their elements cannot be changed.</para>
<para>Tensor elements can be any objects on which the standard
arithmetic operations are defined. However, eigenvalue calculation
is supported only for float elements.
</para>
<methoddescription><methoddef><method>asVector</method></methoddef>
<void/><para>Returns an equivalent vector object (only for rank 1).</para>
</methoddescription>
<methoddescription><methoddef><method>dot</method></methoddef>
<paramdef><parameter>other</parameter></paramdef>
<para>Returns the contraction with <parameter>other</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>trace</method></methoddef>
<paramdef><parameter>axis1</parameter><defaultvalue>0</defaultvalue></paramdef>
<paramdef><parameter>axis2</parameter><defaultvalue>1</defaultvalue></paramdef>
<para>Returns the trace of a rank-2 tensor.</para>
</methoddescription>
<methoddescription><methoddef><method>transpose</method></methoddef>
<void/><para>Returns the transposed (index reversed) tensor.</para>
</methoddescription>
<methoddescription><methoddef><method>symmetricalPart</method></methoddef>
<void/><para>Returns the symmetrical part of a rank-2 tensor.</para>
</methoddescription>
<methoddescription><methoddef><method>asymmetricalPart</method></methoddef>
<void/><para>Returns the asymmetrical part of a rank-2 tensor.</para>
</methoddescription>
<methoddescription><methoddef><method>eigenvalues</method></methoddef>
<void/><para>Returns the eigenvalues of a rank-2 tensor in an array.</para>
</methoddescription>
<methoddescription><methoddef><method>diagonalization</method></methoddef>
<void/><para>Returns the eigenvalues of a rank-2 tensor and a tensor
representing the rotation matrix to the diagonalized form.</para>
</methoddescription>
<methoddescription><methoddef><method>inverse</method></methoddef>
<void/><para>Returns the inverse of a rank-2 tensor.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Vector" xreflabel="Scientific.Geometry.Vector">
<classdef><class>Vector</class><classinfo>Vector in 3D space</classinfo></classdef>
<para>Constructor:</para>
<itemizedlist>
<listitem><para>
Vector(<parameter>x</parameter>, <parameter>y</parameter>, <parameter>z</parameter>)   (from three coordinates)
</para></listitem>
<listitem><para>
Vector(<parameter>coordinates</parameter>)   (from any sequence containing three coordinates)</para></listitem>
</itemizedlist>
<para>Vectors support the usual arithmetic operations
(<literal role="Python">v1</literal>, <literal role="Python">v2</literal>: vectors, <literal role="Python">s</literal>: scalar): </para>
<itemizedlist>
<listitem><para>
<literal role="Python">v1+v2</literal>           (addition)
</para></listitem>
<listitem><para>
<literal role="Python">v1-v2</literal>           (subtraction)
</para></listitem>
<listitem><para>
<literal role="Python">v1*v2</literal>           (scalar product)
</para></listitem>
<listitem><para>
<literal role="Python">s*v1</literal>, <literal role="Python">v1*s</literal>    (multiplication with a scalar)
</para></listitem>
<listitem><para>
<literal role="Python">v1/s</literal>            (division by a scalar)</para></listitem>
</itemizedlist>
<para>The three coordinates can be extracted by indexing.</para>
<para>Vectors are <emphasis>immutable</emphasis>, i.e. their elements cannot be changed.</para>
<para>Vector elements can be any objects on which the standard
arithmetic operations plus the functions sqrt and arccos are defined.
</para>
<methoddescription><methoddef><method>x</method></methoddef>
<void/><para>Returns the x coordinate.</para>
</methoddescription>
<methoddescription><methoddef><method>y</method></methoddef>
<void/><para>Returns the y coordinate.</para>
</methoddescription>
<methoddescription><methoddef><method>z</method></methoddef>
<void/><para>Returns the z coordinate.</para>
</methoddescription>
<methoddescription><methoddef><method>length</method></methoddef>
<void/><para>Returns the length (norm).</para>
</methoddescription>
<methoddescription><methoddef><method>normal</method></methoddef>
<void/><para>Returns a normalized copy.</para>
</methoddescription>
<methoddescription><methoddef><method>cross</method></methoddef>
<paramdef><parameter>other</parameter></paramdef>
<para>Returns the cross product with vector <parameter>other</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>asTensor</method></methoddef>
<void/><para>Returns an equivalent tensor object of rank 1.</para>
</methoddescription>
<methoddescription><methoddef><method>dyadicProduct</method></methoddef>
<paramdef><parameter>other</parameter></paramdef>
<para>Returns the dyadic product with vector or tensor <parameter>other</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>angle</method></methoddef>
<paramdef><parameter>other</parameter></paramdef>
<para>Returns the angle to vector <parameter>other</parameter>.</para>
</methoddescription>
</classdescription>

<sect2 id="Module:Scientific.Geometry.Objects3D" xreflabel="Scientific.Geometry.Objects3D">
<title>Module Scientific.Geometry.Objects3D</title>

<classdescription role="Python" id="Class:Scientific.Geometry.Objects3D.GeometricalObject3D" xreflabel="Scientific.Geometry.Objects3D.GeometricalObject3D">
<classdef><class>GeometricalObject3D</class><classinfo>Geometrical object in 3D space</classinfo></classdef>
<para>This is an abstract base class; to create instances, use one of
the subclasses.
</para>
<methoddescription><methoddef><method>intersectWith</method></methoddef>
<paramdef><parameter>other</parameter></paramdef>
<para>Returns the geometrical object that results from the
intersection with <parameter>other</parameter>. If there is no intersection,
the result is <literal role="Python">None</literal>.</para>
<para>Note that intersection is not implemented for all possible
pairs of objects. A <literal role="Python">ValueError</literal> is raised for combinations
that haven't been implemented yet.</para>
</methoddescription>
<methoddescription><methoddef><method>hasPoint</method></methoddef>
<paramdef><parameter>point</parameter></paramdef>
<para>Returns 1 if <parameter>point</parameter> is in the object.</para>
</methoddescription>
<methoddescription><methoddef><method>distanceFrom</method></methoddef>
<paramdef><parameter>point</parameter></paramdef>
<para>Returns the distance of <parameter>point</parameter> from the closest point of the object.</para>
</methoddescription>
<methoddescription><methoddef><method>volume</method></methoddef>
<void/><para>Returns the volume. The result is <literal role="Python">None</literal> for unbounded objects
and zero for lower-dimensional objects.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Objects3D.Sphere" xreflabel="Scientific.Geometry.Objects3D.Sphere">
<classdef><class>Sphere</class><classinfo>Sphere</classinfo></classdef>
<para>A subclass of GeometricalObject3D.</para>
<para>Constructor: Sphere(<parameter>center</parameter>, <parameter>radius</parameter>), where <parameter>center</parameter> is a vector and
<parameter>radius</parameter> a float.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Objects3D.Plane" xreflabel="Scientific.Geometry.Objects3D.Plane">
<classdef><class>Plane</class><classinfo>Plane</classinfo></classdef>
<para>A subclass of GeometricalObject3D.</para>
<para>Constructor:</para>
<itemizedlist>
<listitem><para>
Plane(<parameter>point</parameter>, <parameter>normal</parameter>), where <parameter>point</parameter> (a vector) is an arbitrary
  point in the plane and <parameter>normal</parameter> (a vector) indicated the direction
  normal to the plane.</para></listitem>
<listitem><para>
Plane(<parameter>p1</parameter>, <parameter>p2</parameter>, <parameter>p3</parameter>), where each argument is a vector and describes
  a point in the plane. The three points may not be colinear.
</para></listitem>
</itemizedlist>
<methoddescription><methoddef><method>projectionOf</method></methoddef>
<paramdef><parameter>point</parameter></paramdef>
<para>Returns the projection of <parameter>point</parameter> onto the plane.</para>
</methoddescription>
<methoddescription><methoddef><method>rotate</method></methoddef>
<paramdef><parameter>axis</parameter></paramdef>
<paramdef><parameter>angle</parameter></paramdef>
<para>Returns a copy of the plane rotated around the coordinate origin.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Objects3D.Cone" xreflabel="Scientific.Geometry.Objects3D.Cone">
<classdef><class>Cone</class><classinfo>Cone</classinfo></classdef>
<para>A subclass of GeometricalObject3D.</para>
<para>Constructor: Cone(<parameter>tip</parameter>, <parameter>axis</parameter>, <parameter>angle</parameter>), where <parameter>tip</parameter> is a vector
indicating the location of the tip, <parameter>axis</parameter> is a vector that
describes the direction of the line of symmetry, and <parameter>angle</parameter> is
the angle between the line of symmetry and the cone surface.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Objects3D.Circle" xreflabel="Scientific.Geometry.Objects3D.Circle">
<classdef><class>Circle</class><classinfo>Circle</classinfo></classdef>
<para>A subclass of GeometricalObject3D.</para>
<para>Constructor: Circle(<parameter>center</parameter>, <parameter>normal</parameter>, <parameter>radius</parameter>), where <parameter>center</parameter>
is a vector indicating the center of the circle, <parameter>normal</parameter> is a
vector describing the direction normal to the plane of the circle,
and <parameter>radius</parameter> is a float.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Objects3D.Line" xreflabel="Scientific.Geometry.Objects3D.Line">
<classdef><class>Line</class><classinfo>Line</classinfo></classdef>
<para>A subclass of GeometricalObject3D.</para>
<para>Constructor: Line(<parameter>point</parameter>, <parameter>direction</parameter>), where <parameter>point</parameter> is a vector
indicating any point on the line and <parameter>direction</parameter> is a vector
describing the direction of the line.
</para>
<methoddescription><methoddef><method>projectionOf</method></methoddef>
<paramdef><parameter>point</parameter></paramdef>
<para>Returns the projection of <parameter>point</parameter> onto the line.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Objects3D.RhombicLattice" xreflabel="Scientific.Geometry.Objects3D.RhombicLattice">
<classdef><class>RhombicLattice</class><classinfo>Lattice with rhombic elementary cell</classinfo></classdef>
<para>A lattice object contains values defined on a finite periodic
structure that is created by replicating a given elementary
cell along the three lattice vectors. The elementary cell can
contain any number of points.</para>
<para>Constructor: RhombicLattice(<parameter>elementary_cell</parameter>, <parameter>lattice_vectors</parameter>, <parameter>cells</parameter>,
                            <parameter>function</parameter>=<literal role="Python">None</literal>, <parameter>base</parameter>=<literal role="Python">None</literal>)</para>
<para><variablelist>
<varlistentry><term><parameter>elementary_cell</parameter></term>
<listitem><para>
a list of the points (vectors) in the elementary cell</para></listitem></varlistentry>
<varlistentry><term><parameter>lattice_vectors</parameter></term>
<listitem><para>
a tuple of three vectors describing the edges
                     of the elementary cell</para></listitem></varlistentry>
<varlistentry><term><parameter>cells</parameter></term>
<listitem><para>
a tuple of three integers, indicating how often the elementary
           cell should be replicated along each lattice vector</para></listitem></varlistentry>
<varlistentry><term><parameter>function</parameter></term>
<listitem><para>
the function to be applied to each point in the lattice
              in order to obtain the value stored in the lattice.
              If no function is specified, the point itself becomes
              the value stored in the lattice.</para></listitem></varlistentry>
<varlistentry><term><parameter>base</parameter></term>
<listitem><para>
an offset added to all lattice points
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Objects3D.BravaisLattice" xreflabel="Scientific.Geometry.Objects3D.BravaisLattice">
<classdef><class>BravaisLattice</class><classinfo>General Bravais lattice</classinfo></classdef>
<para>This is a subclass of RhombicLattice, describing the special case
of an elementary cell containing one point.</para>
<para>Constructor: BravaisLattice(<parameter>lattice_vectors</parameter>, <parameter>cells</parameter>,
                            <parameter>function</parameter>=<literal role="Python">None</literal>, <parameter>base</parameter>=<literal role="Python">None</literal>)</para>
<para><variablelist>
<varlistentry><term><parameter>lattice_vectors</parameter></term>
<listitem><para>
a tuple of three vectors describing the edges
                     of the elementary cell</para></listitem></varlistentry>
<varlistentry><term><parameter>cells</parameter></term>
<listitem><para>
a tuple of three integers, indicating how often the elementary
           cell should be replicated along each lattice vector</para></listitem></varlistentry>
<varlistentry><term><parameter>function</parameter></term>
<listitem><para>
the function to be applied to each point in the lattice
              in order to obtain the value stored in the lattice.
              If no function is specified, the point itself becomes
              the value stored in the lattice.</para></listitem></varlistentry>
<varlistentry><term><parameter>base</parameter></term>
<listitem><para>
an offset added to all lattice points
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Objects3D.SCLattice" xreflabel="Scientific.Geometry.Objects3D.SCLattice">
<classdef><class>SCLattice</class><classinfo>Simple cubic lattice</classinfo></classdef>
<para>This is a subclass of BravaisLattice, describing the special case
of a cubic elementary cell.</para>
<para>Constructor: SCLattice(<parameter>cellsize</parameter>, <parameter>cells</parameter>, <parameter>function</parameter>=<literal role="Python">None</literal>,
                       <parameter>base</parameter>=<literal role="Python">None</literal>)</para>
<para><variablelist>
<varlistentry><term><parameter>cellsize</parameter></term>
<listitem><para>
the edge length of the cubic elementary cell</para></listitem></varlistentry>
<varlistentry><term><parameter>cells</parameter></term>
<listitem><para>
a tuple of three integers, indicating how often the elementary
           cell should be replicated along each lattice vector</para></listitem></varlistentry>
<varlistentry><term><parameter>function</parameter></term>
<listitem><para>
the function to be applied to each point in the lattice
              in order to obtain the value stored in the lattice.
              If no function is specified, the point itself becomes
              the value stored in the lattice.</para></listitem></varlistentry>
<varlistentry><term><parameter>base</parameter></term>
<listitem><para>
an offset added to all lattice points
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

</sect2>

<sect2 id="Module:Scientific.Geometry.Quaternion" xreflabel="Scientific.Geometry.Quaternion">
<title>Module Scientific.Geometry.Quaternion</title>

<classdescription role="Python" id="Class:Scientific.Geometry.Quaternion.Quaternion" xreflabel="Scientific.Geometry.Quaternion.Quaternion">
<classdef><class>Quaternion</class><classinfo>Quaternion (hypercomplex number)</classinfo></classdef>
<para>This implementation of quaternions is not complete; only the features
needed for representing rotation matrices by quaternions are
implemented.</para>
<para>Constructor:</para>
<itemizedlist>
<listitem><para>
Quaternion(<parameter>q0</parameter>, <parameter>q1</parameter>, <parameter>q2</parameter>, <parameter>q3</parameter>)  (from four real components)</para></listitem>
<listitem><para>
Quaternion(<parameter>q</parameter>)  (from a sequence containing the four components)</para></listitem>
</itemizedlist>
<para>Quaternions support addition, subtraction, and multiplication,
as well as multiplication and division by scalars. Division
by quaternions is not provided, because quaternion multiplication
is not associative. Use multiplication by the inverse instead.</para>
<para>The four components can be extracted by indexing.
</para>
<methoddescription><methoddef><method>norm</method></methoddef>
<void/><para>Returns the norm.</para>
</methoddescription>
<methoddescription><methoddef><method>normalized</method></methoddef>
<void/><para>Returns the quaternion scaled to norm 1.</para>
</methoddescription>
<methoddescription><methoddef><method>inverse</method></methoddef>
<void/><para>Returns the inverse.</para>
</methoddescription>
<methoddescription><methoddef><method>asMatrix</method></methoddef>
<void/><para>Returns a 4x4 matrix representation.</para>
</methoddescription>
<methoddescription><methoddef><method>asRotation</method></methoddef>
<void/><para>Returns the corresponding rotation matrix (the quaternion
must be normalized).</para>
</methoddescription>
</classdescription>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Geometry.Quaternion.isQuaternion" xreflabel="Scientific.Geometry.Quaternion.isQuaternion" role="Python"><funcprototype><funcdef><function>isQuaternion</function></funcdef>
<paramdef><parameter>x</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns 1 if <parameter>x</parameter> is a quaternion.</para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.Geometry.TensorAnalysis" xreflabel="Scientific.Geometry.TensorAnalysis">
<title>Module Scientific.Geometry.TensorAnalysis</title>

<classdescription role="Python" id="Class:Scientific.Geometry.TensorAnalysis.TensorField" xreflabel="Scientific.Geometry.TensorAnalysis.TensorField">
<classdef><class>TensorField</class><classinfo>Tensor field of arbitrary rank</classinfo></classdef>
<para>A tensor field is described by a tensor at each point of
a three-dimensional rectangular grid. The grid spacing
may be non-uniform. Tensor fields are implemented as a subclass
of InterpolatingFunction from the module
Scientific.Functions.Interpolation and thus share all methods
defined in that class.</para>
<para>Constructor: TensorField(<parameter>rank</parameter>, <parameter>axes</parameter>, <parameter>values</parameter>, <parameter>default</parameter>=<literal role="Python">None</literal>)</para>
<para><variablelist>
<varlistentry><term><parameter>rank</parameter></term>
<listitem><para>
a non-negative integer indicating the tensor rank</para></listitem></varlistentry>
<varlistentry><term><parameter>axes</parameter></term>
<listitem><para>
a sequence of three one-dimensional arrays, each
          of which specifies one coordinate (x, y, z) of the
          grid points</para></listitem></varlistentry>
<varlistentry><term><parameter>values</parameter></term>
<listitem><para>
an array of <literal role="Python">rank+3</literal> dimensions. Its first
            three dimensions correspond to the x, y, z
            directions and must have lengths compatible with
            the axis arrays. The remaining dimensions must
            have length 3.</para></listitem></varlistentry>
<varlistentry><term><parameter>default</parameter></term>
<listitem><para>
the value of the field for points outside the grid.
             A value of <literal role="Python">None</literal> means that an exception will be
             raised for an attempt to evaluate the field outside
             the grid. Any other value must a tensor of the
             correct rank.</para></listitem></varlistentry>
</variablelist></para>
<para>Evaluation:</para>
<itemizedlist>
<listitem><para>
<literal role="Python">tensorfield(x, y, z)</literal>   (three coordinates)
</para></listitem>
<listitem><para>
<literal role="Python">tensorfield(coordinates)</literal>  (any sequence containing three coordinates)
</para></listitem>
</itemizedlist>
<methoddescription><methoddef><method>zero</method></methoddef>
<void/><para>Returns a tensor of the correct rank with zero elements.</para>
</methoddescription>
<methoddescription><methoddef><method>derivative</method></methoddef>
<paramdef><parameter>variable</parameter></paramdef>
<para>Returns the derivative with respect to <parameter>variable</parameter>, which
must be one of 0, 1, or 2.</para>
</methoddescription>
<methoddescription><methoddef><method>allDerivatives</method></methoddef>
<void/><para>Returns all three derivatives (x, y, z).</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.TensorAnalysis.ScalarField" xreflabel="Scientific.Geometry.TensorAnalysis.ScalarField">
<classdef><class>ScalarField</class><classinfo>Scalar field (tensor field of rank 0)</classinfo></classdef>
<para>Constructor: ScalarField(<parameter>axes</parameter>, <parameter>values</parameter>, <parameter>default</parameter>=<literal role="Python">None</literal>)</para>
<para>A subclass of TensorField.
</para>
<methoddescription><methoddef><method>gradient</method></methoddef>
<void/><para>Returns the gradient (a vector field).</para>
</methoddescription>
<methoddescription><methoddef><method>laplacian</method></methoddef>
<void/><para>Returns the laplacian (a scalar field).</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.TensorAnalysis.VectorField" xreflabel="Scientific.Geometry.TensorAnalysis.VectorField">
<classdef><class>VectorField</class><classinfo>Vector field (tensor field of rank 1)</classinfo></classdef>
<para>Constructor: VectorField(<parameter>axes</parameter>, <parameter>values</parameter>, <parameter>default</parameter>=<literal role="Python">None</literal>)</para>
<para>A subclass of TensorField.
</para>
<methoddescription><methoddef><method>divergence</method></methoddef>
<void/><para>Returns the divergence (a scalar field).</para>
</methoddescription>
<methoddescription><methoddef><method>curl</method></methoddef>
<void/><para>Returns the curl (a vector field).</para>
</methoddescription>
<methoddescription><methoddef><method>strain</method></methoddef>
<void/><para>Returns the strain (a tensor field of rank 2).</para>
</methoddescription>
<methoddescription><methoddef><method>divergenceCurlAndStrain</method></methoddef>
<void/><para>Returns all derivative fields: divergence, curl, and strain.</para>
</methoddescription>
<methoddescription><methoddef><method>laplacian</method></methoddef>
<void/><para>Returns the laplacian (a vector field).</para>
</methoddescription>
<methoddescription><methoddef><method>length</method></methoddef>
<void/><para>Returns a scalar field corresponding to the length (norm) of
the vector field.</para>
</methoddescription>
</classdescription>

</sect2>

<sect2 id="Module:Scientific.Geometry.Transformation" xreflabel="Scientific.Geometry.Transformation">
<title>Module Scientific.Geometry.Transformation</title>

<classdescription role="Python" id="Class:Scientific.Geometry.Transformation.Transformation" xreflabel="Scientific.Geometry.Transformation.Transformation">
<classdef><class>Transformation</class><classinfo>Linear coordinate transformation.</classinfo></classdef>
<para>Transformation objects represent linear coordinate transformations
in a 3D space. They can be applied to vectors, returning another vector.
If <literal role="Python">t</literal> is a transformation and <literal role="Python">v</literal> is a vector, <literal role="Python">t(v)</literal> returns
the transformed vector.</para>
<para>Transformations support composition: if <literal role="Python">t1</literal> and <literal role="Python">t2</literal> are transformation
objects, <literal role="Python">t1*t2</literal> is another transformation object which corresponds
to applying t1 <emphasis>after</emphasis> t2.</para>
<para>This class is an abstract base class. Instances can only be created
of concrete subclasses, i.e. translations or rotations.
</para>
<methoddescription><methoddef><method>rotation</method></methoddef>
<void/><para>Returns the rotational component.</para>
</methoddescription>
<methoddescription><methoddef><method>translation</method></methoddef>
<void/><para>Returns the translational component. In the case of a mixed
rotation/translation, this translation is executed
<emphasis>after</emphasis> the rotation.</para>
</methoddescription>
<methoddescription><methoddef><method>inverse</method></methoddef>
<void/><para>Returns the inverse transformation.</para>
</methoddescription>
<methoddescription><methoddef><method>screwMotion</method></methoddef>
<void/><para>Returns the four parameters <literal role="Python">(reference, direction, angle,
distance)</literal> of a screw-like motion that is equivalent to the
transformation. The screw motion consists of a displacement
of <literal role="Python">distance</literal> (a float) along <literal role="Python">direction</literal> (a normalized vector)
plus a rotation of <literal role="Python">angle</literal> radians around an axis pointing along
<literal role="Python">direction</literal> and passing through the point <literal role="Python">reference</literal> (a vector).
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Transformation.Translation" xreflabel="Scientific.Geometry.Transformation.Translation">
<classdef><class>Translation</class><classinfo>Translational transformation.</classinfo></classdef>
<para>This is a subclass of Transformation.</para>
<para>Constructor: Translation(<parameter>vector</parameter>), where <parameter>vector</parameter> is the displacement
vector.
</para>
<methoddescription><methoddef><method>displacement</method></methoddef>
<void/><para>Returns the displacement vector.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Transformation.Rotation" xreflabel="Scientific.Geometry.Transformation.Rotation">
<classdef><class>Rotation</class><classinfo>Rotational transformation.</classinfo></classdef>
<para>This is a subclass of Transformation.</para>
<para>Constructor:</para>
<itemizedlist>
<listitem><para>
Rotation(<parameter>tensor</parameter>), where <parameter>tensor</parameter> is a tensor object containing
  the rotation matrix.</para></listitem>
<listitem><para>
Rotation(<parameter>axis</parameter>, <parameter>angle</parameter>), where <parameter>axis</parameter> is a vector and <parameter>angle</parameter>
  a number (the angle in radians).
</para></listitem>
</itemizedlist>
<methoddescription><methoddef><method>axisAndAngle</method></methoddef>
<void/><para>Returns the axis (a normalized vector) and angle (a float,
in radians).</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Geometry.Transformation.RotationTranslation" xreflabel="Scientific.Geometry.Transformation.RotationTranslation">
<classdef><class>RotationTranslation</class><classinfo>Combined translational and rotational transformation.</classinfo></classdef>
<para>This is a subclass of Transformation.</para>
<para>Objects of this class are not created directly, but can be the
result of a composition of rotations and translations.
</para>
</classdescription>

</sect2>

</sect1>

<sect1 id="Module:Scientific.IO" xreflabel="Scientific.IO">
<title>Module Scientific.IO</title>

<sect2 id="Module:Scientific.IO.ArrayIO" xreflabel="Scientific.IO.ArrayIO">
<title>Module Scientific.IO.ArrayIO</title>

<para>This module contains elementary support for I/O of one- and
two-dimensional numerical arrays to and from plain text files. The
text file format is very simple and used by many other programs as
well:</para>
<itemizedlist>
<listitem><para>
each line corresponds to one row of the array</para></listitem>
<listitem><para>
the numbers within a line are separated by white space</para></listitem>
<listitem><para>
lines starting with # are ignored (comment lines)</para></listitem>
</itemizedlist>
<para>An array containing only one line or one column is returned as a
one-dimensional array on reading. One-dimensional arrays are written
as one item per line.</para>
<para>Numbers in files to be read must conform to Python/C syntax.  For
reading files containing Fortran-style double-precision numbers
(exponent prefixed by D), use the module Scientific.IO.FortranFormat.
</para>
<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.IO.ArrayIO.readArray" xreflabel="Scientific.IO.ArrayIO.readArray" role="Python"><funcprototype><funcdef><function>readArray</function></funcdef>
<paramdef><parameter>filename</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Return an array containing the data from file <parameter>filename</parameter>. This
function works for arbitrary data types (every array element can be
given by an arbitrary Python expression), but at the price of being
slow. For large arrays, use readFloatArray or readIntegerArray
if possible.</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.IO.ArrayIO.readFloatArray" xreflabel="Scientific.IO.ArrayIO.readFloatArray" role="Python"><funcprototype><funcdef><function>readFloatArray</function></funcdef>
<paramdef><parameter>filename</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Return a floating-point array containing the data from file <parameter>filename</parameter>.</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.IO.ArrayIO.readIntegerArray" xreflabel="Scientific.IO.ArrayIO.readIntegerArray" role="Python"><funcprototype><funcdef><function>readIntegerArray</function></funcdef>
<paramdef><parameter>filename</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Return an integer array containing the data from file <parameter>filename</parameter>.</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.IO.ArrayIO.writeArray" xreflabel="Scientific.IO.ArrayIO.writeArray" role="Python"><funcprototype><funcdef><function>writeArray</function></funcdef>
<paramdef><parameter>array</parameter></paramdef>
<paramdef><parameter>filename</parameter></paramdef>
<paramdef><parameter>mode</parameter><defaultvalue>'w'</defaultvalue></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Write array <parameter>a</parameter> to file <parameter>filename</parameter>. <parameter>mode</parameter> can be <literal role="Python">w</literal> (new file)
or <literal role="Python">a</literal> (append).</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.IO.ArrayIO.writeDataSets" xreflabel="Scientific.IO.ArrayIO.writeDataSets" role="Python"><funcprototype><funcdef><function>writeDataSets</function></funcdef>
<paramdef><parameter>datasets</parameter></paramdef>
<paramdef><parameter>filename</parameter></paramdef>
<paramdef><parameter>separator</parameter><defaultvalue>''</defaultvalue></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Write each of the items in the sequence <parameter>datasets</parameter>
to the file <parameter>filename</parameter>, separating the datasets by a line
containing <parameter>separator</parameter>. The items in the data sets can be
one- or two-dimensional arrays or equivalent nested sequences.
The output file format is understood by many plot programs.
</para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.IO.FortranFormat" xreflabel="Scientific.IO.FortranFormat">
<title>Module Scientific.IO.FortranFormat</title>

<para>Fortran-compatible input/output</para>
<para>This module provides two classes that aid in reading and writing
Fortran-formatted text files.</para>
<example><title>Examples:</title><para>  Input:</para>
<programlisting role="Python">
s = '   59999'
format = FortranFormat('2I4')
line = FortranLine(s, format)
print line[0]
print line[1]</programlisting><para>  prints</para>
<programlisting role="Python">
5
9999</programlisting><para>  Output:</para>
<programlisting role="Python">
format = FortranFormat('2D15.5')
line = FortranLine([3.1415926, 2.71828], format)
print str(line)</programlisting><para>  prints</para>
<para>  <literal role="Python">3.14159D+00    2.71828D+00</literal>
</para>
</example>
<classdescription role="Python" id="Class:Scientific.IO.FortranFormat.FortranLine" xreflabel="Scientific.IO.FortranFormat.FortranLine">
<classdef><class>FortranLine</class><classinfo>Fortran-style record in formatted files</classinfo></classdef>
<para>FortranLine objects represent the content of one record of a
Fortran-style formatted file. Indexing yields the contents as
Python objects, whereas transformation to a string (using the
built-in function <literal role="Python">str</literal>) yields the text representation.</para>
<para>Constructor: FortranLine(<parameter>data</parameter>, <parameter>format</parameter>, <parameter>length</parameter>=<literal role="Python">80</literal>)</para>
<para><variablelist>
<varlistentry><term><parameter>data</parameter></term>
<listitem><para>
either a sequence of Python objects, or a string
          formatted according to Fortran rules</para></listitem></varlistentry>
<varlistentry><term><parameter>format</parameter></term>
<listitem><para>
either a Fortran-style format string, or a
            FortranFormat object. A FortranFormat should
            be used when the same format string is used repeatedly,
            because then the rather slow parsing of the string
            is performed only once.</para></listitem></varlistentry>
<varlistentry><term><parameter>length</parameter></term>
<listitem><para>
the length of the Fortran record. This is relevant
            only when <parameter>data</parameter> is a string; this string is then
            extended by spaces to have the indicated length.
            The default value of 80 is almost always correct.</para></listitem></varlistentry>
</variablelist></para>
<para>Restrictions:</para>
<para>1) Only A, D, E, F, G, I, and X formats are supported (plus string
   constants for output).</para>
<para>2) No direct support for complex numbers; they must be split into
   real and imaginary parts before output.</para>
<para>3) No overflow check. If an output field gets too large, it will
   take more space, instead of being replaced by stars according
   to Fortran conventions.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.FortranFormat.FortranFormat" xreflabel="Scientific.IO.FortranFormat.FortranFormat">
<classdef><class>FortranFormat</class><classinfo>Parsed fortran-style format string</classinfo></classdef>
<para>Constructor: FortranFormat(<parameter>format</parameter>), where <parameter>format</parameter> is a
format specification according to Fortran rules.
</para>
</classdescription>

</sect2>

<sect2 id="Module:Scientific.IO.NetCDF" xreflabel="Scientific.IO.NetCDF">
<title>Module Scientific.IO.NetCDF</title>

<classdescription role="Python" id="Class:Scientific.IO.NetCDF.NetCDFFile" xreflabel="Scientific.IO.NetCDF.NetCDFFile">
<classdef><class>NetCDFFile</class><classinfo>netCDF file</classinfo></classdef>
<para>Constructor: NetCDFFile(<parameter>filename</parameter>, <parameter>mode</parameter>=<literal role="Python">"r"</literal>)</para>
<para><variablelist>
<varlistentry><term><parameter>filename</parameter></term>
<listitem><para>
name of the netCDF file. By convention, netCDF files
              have the extension ".nc", but this is not enforced.
              The filename may contain a home directory indication
              starting with "~".</para></listitem></varlistentry>
<varlistentry><term><parameter>mode</parameter></term>
<listitem><para>
access mode. "r" means read-only; no data can be modified.
          "w" means write; a new file is created, an existing
          file with the same name is deleted. "a" means append
          (in analogy with serial files); an existing file is
          opened for reading and writing, and if the file does
          not exist it is created. "r+" is similar to "a",
          but the file must already exist. An "s" can be appended
          to any of the modes listed above; it indicates that the
          file will be opened or created in "share" mode, which
          reduces buffering in order to permit simultaneous read
          access by other processes to a file that is being written.</para></listitem></varlistentry>
</variablelist></para>
<para>A NetCDFFile object has two standard attributes: <literal role="Python">dimensions</literal> and
<literal role="Python">variables</literal>. The values of both are dictionaries, mapping dimension
names to their associated lengths and variable names to variables,
respectively. Application programs should never modify these
dictionaries.</para>
<para>All other attributes correspond to global attributes defined in the
netCDF file. Global file attributes are created by assigning to
an attribute of the NetCDFFile object. 
</para>
<methoddescription><methoddef><method>close</method></methoddef>
<void/><para>Closes the file. Any read or write access to the file
or one of its variables after closing raises an exception.</para>
</methoddescription>
<methoddescription><methoddef><method>createDimension</method></methoddef>
<paramdef><parameter>name</parameter></paramdef>
<paramdef><parameter>length</parameter></paramdef>
<para>Creates a new dimension with the given <parameter>name</parameter> and
<parameter>length</parameter>. <parameter>length</parameter> must be a positive integer or <literal role="Python">None</literal>,
which stands for the unlimited dimension. Note that there can
be only one unlimited dimension in a file.</para>
</methoddescription>
<methoddescription><methoddef><method>createVariable</method></methoddef>
<paramdef><parameter>name</parameter></paramdef>
<paramdef><parameter>type</parameter></paramdef>
<paramdef><parameter>dimensions</parameter></paramdef>
<para>Creates a new variable with the given <parameter>name</parameter>, <parameter>type</parameter>, and
<parameter>dimensions</parameter>. The <parameter>type</parameter> is a one-letter string with the same
meaning as the typecodes for arrays in module Numeric; in
practice the predefined type constants from Numeric should
be used. <parameter>dimensions</parameter> must be a tuple containing dimension
names (strings) that have been defined previously.</para>
<para>The return value is the NetCDFVariable object describing the
new variable.</para>
</methoddescription>
<methoddescription><methoddef><method>sync</method></methoddef>
<void/><para>Writes all buffered data to the disk file.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.NetCDF.NetCDFVariable" xreflabel="Scientific.IO.NetCDF.NetCDFVariable">
<classdef><class>NetCDFVariable</class><classinfo>Variable in a netCDF file</classinfo></classdef>
<para>NetCDFVariable objects are constructed by calling the method
<literal role="Python">createVariable</literal> on the NetCDFFile object.</para>
<para>NetCDFVariable objects behave much like array objects defined
in module Numeric, except that their data resides in a file.
Data is read by indexing and written by assigning to an
indexed subset; the entire array can be accessed by the index
<literal role="Python">[:]</literal> or using the methods <literal role="Python">getValue</literal> and
<literal role="Python">assignValue</literal>. NetCDFVariable objects also have attribute
"shape" with the same meaning as for arrays, but the shape
cannot be modified. There is another read-only attribute
"dimensions", whose value is the tuple of dimension names.</para>
<para>All other attributes correspond to variable attributes defined in the
netCDF file. Variable attributes are created by assigning to
an attribute of the NetCDFVariable object. </para>
<para>Note:
If a file open for reading is simultaneously written by another program,
the size of the unlimited dimension may change. Every time the shape
of a variable is requested, the current size will be obtained from
the file. For reading and writing, the size obtained during the last
shape request is used. This ensures consistency: foo[-1] means the
same thing no matter how often it is evaluated, as long as the shape
is not re-evaluated in between.
</para>
<methoddescription><methoddef><method>assignValue</method></methoddef>
<paramdef><parameter>value</parameter></paramdef>
<para>Assigns <parameter>value</parameter> to the variable. This method allows
assignment to scalar variables, which cannot be indexed.</para>
</methoddescription>
<methoddescription><methoddef><method>getValue</method></methoddef>
<void/><para>Returns the value of the variable. This method allows
access to scalar variables, which cannot be indexed.</para>
</methoddescription>
<methoddescription><methoddef><method>typecode</method></methoddef>
<void/><para>Return the variable's type code (a string).</para>
</methoddescription>
</classdescription>

</sect2>

<sect2 id="Module:Scientific.IO.PDB" xreflabel="Scientific.IO.PDB">
<title>Module Scientific.IO.PDB</title>

<para>This module provides classes that represent PDB (Protein Data Bank)
files and configurations contained in PDB files. It provides access to
PDB files on two levels: low-level (line by line) and high-level
(chains, residues, and atoms).</para>
<para>Caution: The PDB file format has been heavily abused, and it is
probably impossible to write code that can deal with all variants
correctly. This modules tries to read the widest possible range of PDB
files, but gives priority to a correct interpretation of the PDB
format as defined by the Brookhaven National Laboratory.</para>
<para>A special problem are atom names. The PDB file format specifies that
the first two letters contain the right-justified chemical element
name. A later modification allowed the initial space in hydrogen names
to be replaced by a digit. Many programs ignore all this and treat the
name as an arbitrary left-justified four-character name. This makes it
difficult to extract the chemical element accurately; most programs
write the <literal role="Python">"CA"</literal> for C_alpha in such a way that it actually stands for
a calcium atom! For this reason a special element field has been added
later, but only few files use it.</para>
<para>The low-level routines in this module do not try to deal with the atom
name problem; they return and expect four-character atom names
including spaces in the correct positions. The high-level routines use
atom names without leading or trailing spaces, but provide and use the
element field whenever possible. For output, they use the element
field to place the atom name correctly, and for input, they construct
the element field content from the atom name if no explicit element
field is found in the file.</para>
<para>Except where indicated, numerical values use the same units and
conventions as specified in the PDB format description.</para>
<example><title>Example:</title><programlisting role="Python">
conf = Structure('example.pdb')
print conf
for residue in conf.residues:
    for atom in residue:
        print atom
</programlisting></example>
<classdescription role="Python" id="Class:Scientific.IO.PDB.HetAtom" xreflabel="Scientific.IO.PDB.HetAtom">
<classdef><class>HetAtom</class><classinfo>HetAtom in a PDB structure</classinfo></classdef>
<para>A subclass of Atom, which differs only in the return value
of the method type().</para>
<para>Constructor: HetAtom(<parameter>name</parameter>, <parameter>position</parameter>, <parameter>**properties</parameter>).
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.Group" xreflabel="Scientific.IO.PDB.Group">
<classdef><class>Group</class><classinfo>Atom group (residue or molecule) in a PDB file</classinfo></classdef>
<para>This is an abstract base class. Instances can be created using
one of the subclasses (Molecule, AminoAcidResidue, NucleotideResidue).</para>
<para>Group objects permit iteration over atoms with for-loops,
as well as extraction of atoms by indexing with the
atom name.
</para>
<methoddescription><methoddef><method>addAtom</method></methoddef>
<paramdef><parameter>atom</parameter></paramdef>
<para>Adds <parameter>atom</parameter> (an Atom object) to the group.</para>
</methoddescription>
<methoddescription><methoddef><method>deleteAtom</method></methoddef>
<paramdef><parameter>atom</parameter></paramdef>
<para>Removes <parameter>atom</parameter> (an Atom object) from the group. An exception
will be raised if <parameter>atom</parameter> is not part of the group.
</para>
</methoddescription>
<methoddescription><methoddef><method>deleteHydrogens</method></methoddef>
<void/><para>Removes all hydrogen atoms.</para>
</methoddescription>
<methoddescription><methoddef><method>changeName</method></methoddef>
<paramdef><parameter>name</parameter></paramdef>
<para>Sets the PDB residue name to <parameter>name</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>writeToFile</method></methoddef>
<paramdef><parameter>file</parameter></paramdef>
<para>Writes the group to <parameter>file</parameter> (a PDBFile object or a
string containing a file name).
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.Chain" xreflabel="Scientific.IO.PDB.Chain">
<classdef><class>Chain</class><classinfo>Chain of PDB residues</classinfo></classdef>
<para>This is an abstract base class. Instances can be created using
one of the subclasses (PeptideChain, NucleotideChain).</para>
<para>Chain objects respond to len() and return their residues
by indexing with integers.
</para>
<methoddescription><methoddef><method>sequence</method></methoddef>
<void/><para>Returns the list of residue names.</para>
</methoddescription>
<methoddescription><methoddef><method>addResidue</method></methoddef>
<paramdef><parameter>residue</parameter></paramdef>
<para>Add <parameter>residue</parameter> at the end of the chain.</para>
</methoddescription>
<methoddescription><methoddef><method>removeResidues</method></methoddef>
<paramdef><parameter>first</parameter></paramdef>
<paramdef><parameter>last</parameter></paramdef>
<para>Remove residues starting from <parameter>first</parameter> up to (but not
including) <parameter>last</parameter>. If <parameter>last</parameter> is <literal role="Python">None</literal>, remove everything
starting from <parameter>first</parameter>.
</para>
</methoddescription>
<methoddescription><methoddef><method>deleteHydrogens</method></methoddef>
<void/><para>Removes all hydrogen atoms.</para>
</methoddescription>
<methoddescription><methoddef><method>writeToFile</method></methoddef>
<paramdef><parameter>file</parameter></paramdef>
<para>Writes the chain to <parameter>file</parameter> (a PDBFile object or a
string containing a file name).
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.Molecule" xreflabel="Scientific.IO.PDB.Molecule">
<classdef><class>Molecule</class><classinfo>Molecule in a PDB file</classinfo></classdef>
<para>A subclass of Group.</para>
<para>Constructor: Molecule(<parameter>name</parameter>, <parameter>atoms</parameter>=<literal role="Python">None</literal>, <parameter>number</parameter>=None),
where <parameter>name</parameter> is the PDB residue name. An optional list
of <parameter>atoms</parameter> can be specified, otherwise the molecule is initially
empty. The optional <parameter>number</parameter> is the PDB residue number.</para>
<para>Note: In PDB files, non-chain molecules are treated as residues,
there is no separate molecule definition. This modules defines
every residue as a molecule that is not an amino acid residue or a
nucleotide residue.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.PDBFile" xreflabel="Scientific.IO.PDB.PDBFile">
<classdef><class>PDBFile</class><classinfo>PDB file with access at the record level</classinfo></classdef>
<para>Constructor: PDBFile(<parameter>filename</parameter>, <parameter>mode</parameter>=<literal role="Python">"r"</literal>), where <parameter>filename</parameter>
is the file name and <parameter>mode</parameter> is <literal role="Python">"r"</literal> for reading and <literal role="Python">"w"</literal> for writing,
The low-level file access is handled by the module
Scientific.IO.TextFile, therefore compressed files and URLs
(for reading) can be used as well.
</para>
<methoddescription><methoddef><method>readLine</method></methoddef>
<void/><para>Returns the contents of the next non-blank line (= record).
The return value is a tuple whose first element (a string)
contains the record type. For supported record types (HEADER,
ATOM, HETATM, ANISOU, TERM, MODEL, CONECT), the items from the
remaining fields are put into a dictionary which is returned
as the second tuple element. Most dictionary elements are
strings or numbers; atom positions are returned as a vector,
and anisotropic temperature factors are returned as a rank-2
tensor, already multiplied by 1.e-4. White space is stripped
from all strings except for atom names, whose correct
interpretation can depend on an initial space. For unsupported
record types, the second tuple element is a string containing
the remaining part of the record.
</para>
</methoddescription>
<methoddescription><methoddef><method>writeLine</method></methoddef>
<paramdef><parameter>type</parameter></paramdef>
<paramdef><parameter>data</parameter></paramdef>
<para>Writes a line using record type and data dictionary in the
same format as returned by readLine(). Default values are
provided for non-essential information, so the data dictionary
need not contain all entries.
</para>
</methoddescription>
<methoddescription><methoddef><method>writeComment</method></methoddef>
<paramdef><parameter>text</parameter></paramdef>
<para>Writes <parameter>text</parameter> into one or several comment lines.
Each line of the text is prefixed with <literal role="Python">REMARK</literal> and written
to the file.
</para>
</methoddescription>
<methoddescription><methoddef><method>writeAtom</method></methoddef>
<paramdef><parameter>name</parameter></paramdef>
<paramdef><parameter>position</parameter></paramdef>
<paramdef><parameter>occupancy</parameter><defaultvalue>0.0</defaultvalue></paramdef>
<paramdef><parameter>temperature_factor</parameter><defaultvalue>0.0</defaultvalue></paramdef>
<paramdef><parameter>element</parameter><defaultvalue>''</defaultvalue></paramdef>
<para>Writes an ATOM or HETATM record using the <parameter>name</parameter>, <parameter>occupancy</parameter>,
<parameter>temperature</parameter> and <parameter>element</parameter> information supplied. The residue and
chain information is taken from the last calls to the methods
nextResidue() and nextChain().
</para>
</methoddescription>
<methoddescription><methoddef><method>nextResidue</method></methoddef>
<paramdef><parameter>name</parameter></paramdef>
<paramdef><parameter>number</parameter><defaultvalue>None</defaultvalue></paramdef>
<paramdef><parameter>terminus</parameter><defaultvalue>None</defaultvalue></paramdef>
<para>Signals the beginning of a new residue, starting with the
next call to writeAtom(). The residue name is <parameter>name</parameter>, and a
<parameter>number</parameter> can be supplied optionally; by default residues in a
chain will be numbered sequentially starting from 1. The
value of <parameter>terminus</parameter> can be <literal role="Python">None</literal>, <literal role="Python">"C"</literal>, or <literal role="Python">"N"</literal>; it is passed
to export filters that can use this information in order to
use different atom or residue names in terminal residues.
</para>
</methoddescription>
<methoddescription><methoddef><method>nextChain</method></methoddef>
<paramdef><parameter>chain_id</parameter><defaultvalue>None</defaultvalue></paramdef>
<paramdef><parameter>segment_id</parameter><defaultvalue>''</defaultvalue></paramdef>
<para>Signals the beginning of a new chain. A chain identifier
(string of length one) can be supplied as <parameter>chain_id</parameter>, by
default consecutive letters from the alphabet are used.
The equally optional <parameter>segment_id</parameter> defaults to an empty string.
</para>
</methoddescription>
<methoddescription><methoddef><method>terminateChain</method></methoddef>
<void/><para>Signals the end of a chain.</para>
</methoddescription>
<methoddescription><methoddef><method>close</method></methoddef>
<void/><para>Closes the file. This method <emphasis>must</emphasis> be called for write mode
because otherwise the file will be incomplete.
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.Atom" xreflabel="Scientific.IO.PDB.Atom">
<classdef><class>Atom</class><classinfo>Atom in a PDB structure</classinfo></classdef>
<para>Constructor: Atom(<parameter>name</parameter>, <parameter>position</parameter>, <parameter>**properties</parameter>),
where <parameter>name</parameter> is the PDB atom name (a string),
<parameter>position</parameter> is a atom position (a vector), and
<parameter>properties</parameter> can include any of the other items that
can be stored in an atom record.</para>
<para>The properties can be obtained or modified using
indexing, as for Python dictionaries.
</para>
<methoddescription><methoddef><method>type</method></methoddef>
<void/><para>Returns the six-letter record type, ATOM or HETATM.</para>
</methoddescription>
<methoddescription><methoddef><method>writeToFile</method></methoddef>
<paramdef><parameter>file</parameter></paramdef>
<para>Writes an atom record to <parameter>file</parameter> (a PDBFile object or a
string containing a file name).</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.AminoAcidResidue" xreflabel="Scientific.IO.PDB.AminoAcidResidue">
<classdef><class>AminoAcidResidue</class><classinfo>Amino acid residue in a PDB file</classinfo></classdef>
<para>A subclass of Group.</para>
<para>Constructor: AminoAcidResidue(<parameter>name</parameter>, <parameter>atoms</parameter>=<literal role="Python">None</literal>, <parameter>number</parameter>=None),
where <parameter>name</parameter> is the PDB residue name. An optional list
of <parameter>atoms</parameter> can be specified, otherwise the residue is initially
empty. The optional <parameter>number</parameter> is the PDB residue number.
</para>
<methoddescription><methoddef><method>isCTerminus</method></methoddef>
<void/><para>Returns 1 if the residue is in C-terminal configuration,
i.e. if it has a second oxygen bound to the carbon atom of
the peptide group.
</para>
</methoddescription>
<methoddescription><methoddef><method>isNTerminus</method></methoddef>
<void/><para>Returns 1 if the residue is in N-terminal configuration,
i.e. if it contains more than one hydrogen bound to be
nitrogen atom of the peptide group.
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.NucleotideResidue" xreflabel="Scientific.IO.PDB.NucleotideResidue">
<classdef><class>NucleotideResidue</class><classinfo>Nucleotide residue in a PDB file</classinfo></classdef>
<para>A subclass of Group.</para>
<para>Constructor: NucleotideResidue(<parameter>name</parameter>, <parameter>atoms</parameter>=<literal role="Python">None</literal>, <parameter>number</parameter>=None),
where <parameter>name</parameter> is the PDB residue name. An optional list
of <parameter>atoms</parameter> can be specified, otherwise the residue is initially
empty. The optional <parameter>number</parameter> is the PDB residue number.
</para>
<methoddescription><methoddef><method>hasRibose</method></methoddef>
<void/><para>Returns 1 if the residue has an atom named O2*.</para>
</methoddescription>
<methoddescription><methoddef><method>hasDesoxyribose</method></methoddef>
<void/><para>Returns 1 if the residue has no atom named O2*.</para>
</methoddescription>
<methoddescription><methoddef><method>hasPhosphate</method></methoddef>
<void/><para>Returns 1 if the residue has a phosphate group.</para>
</methoddescription>
<methoddescription><methoddef><method>hasTerminalH</method></methoddef>
<void/><para>Returns 1 if the residue has a 3-terminal H atom.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.PeptideChain" xreflabel="Scientific.IO.PDB.PeptideChain">
<classdef><class>PeptideChain</class><classinfo>Peptide chain in a PDB file</classinfo></classdef>
<para>A subclass of Chain.</para>
<para>Constructor: PeptideChain(<parameter>residues</parameter>=<literal role="Python">None</literal>, <parameter>chain_id</parameter>=<literal role="Python">None</literal>,
                          <parameter>segment_id</parameter>=<literal role="Python">None</literal>), where <parameter>chain_id</parameter>
is a one-letter chain identifier and <parameter>segment_id</parameter> is
a multi-character chain identifier, both are optional. A list
of AminoAcidResidue objects can be passed as <parameter>residues</parameter>; by
default a peptide chain is initially empty.
</para>
<methoddescription><methoddef><method>isTerminated</method></methoddef>
<void/><para>Returns 1 if the last residue is in C-terminal configuration.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.NucleotideChain" xreflabel="Scientific.IO.PDB.NucleotideChain">
<classdef><class>NucleotideChain</class><classinfo>Nucleotide chain in a PDB file</classinfo></classdef>
<para>A subclass of Chain.</para>
<para>Constructor: NucleotideChain(<parameter>residues</parameter>=<literal role="Python">None</literal>, <parameter>chain_id</parameter>=<literal role="Python">None</literal>,
                             <parameter>segment_id</parameter>=<literal role="Python">None</literal>), where <parameter>chain_id</parameter>
is a one-letter chain identifier and <parameter>segment_id</parameter> is
a multi-character chain identifier, both are optional. A list
of NucleotideResidue objects can be passed as <parameter>residues</parameter>; by
default a nucleotide chain is initially empty.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.ResidueNumber" xreflabel="Scientific.IO.PDB.ResidueNumber">
<classdef><class>ResidueNumber</class><classinfo>PDB residue number</classinfo></classdef>
<para>Most PDB residue numbers are simple integers, but when insertion
codes are used a number can consist of an integer plus a letter.
Such compound residue numbers are represented by this class.</para>
<para>Constructor: ResidueNumber(<parameter>number</parameter>, <parameter>insertion_code</parameter>)
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.IO.PDB.Structure" xreflabel="Scientific.IO.PDB.Structure">
<classdef><class>Structure</class><classinfo>A high-level representation of the contents of a PDB file</classinfo></classdef>
<para>Constructor: Structure(<parameter>filename</parameter>, <parameter>model</parameter>=<literal role="Python">0</literal>, <parameter>alternate_code</parameter>=<literal role="Python">"A"</literal>),
where <parameter>filename</parameter> is the name of the PDB file. Compressed files
and URLs are accepted, as for class PDBFile. The two optional
arguments specify which data should be read in case of a
multiple-model file or in case of a file that contains alternative
positions for some atoms.</para>
<para>The components of a system can be accessed in several ways
(<literal role="Python">s</literal> is an instance of this class):</para>
<itemizedlist>
<listitem><para>
<literal role="Python">s.residues</literal> is a list of all PDB residues, in the order in
  which they occurred in the file.</para></listitem>
<listitem><para>
<literal role="Python">s.peptide_chains</literal> is a list of PeptideChain objects, containing
  all peptide chains in the file in their original order.</para></listitem>
<listitem><para>
<literal role="Python">s.nucleotide_chains</literal> is a list of NucleotideChain objects, containing
  all nucleotide chains in the file in their original order.</para></listitem>
<listitem><para>
<literal role="Python">s.molecules</literal> is a list of all PDB residues that are neither
  amino acid residues nor nucleotide residues, in their original
  order.</para></listitem>
<listitem><para>
<literal role="Python">s.objects</literal> is a list of all high-level objects (peptide chains,
  nucleotide chains, and molecules) in their original order.</para></listitem>
</itemizedlist>
<para>An iteration over a Structure instance by a for-loop is equivalent
to an iteration over the residue list.
</para>
<methoddescription><methoddef><method>deleteHydrogens</method></methoddef>
<void/><para>Removes all hydrogen atoms.</para>
</methoddescription>
<methoddescription><methoddef><method>splitPeptideChain</method></methoddef>
<paramdef><parameter>number</parameter></paramdef>
<paramdef><parameter>position</parameter></paramdef>
<para>Splits the peptide chain indicated by <parameter>number</parameter> (0 being
the first peptide chain in the PDB file) after the residue indicated
by <parameter>position</parameter> (0 being the first residue of the chain).
The two chain fragments remain adjacent in the peptide chain
list, i.e. the numbers of all following nucleotide chains increase
by one.
</para>
</methoddescription>
<methoddescription><methoddef><method>splitNucleotideChain</method></methoddef>
<paramdef><parameter>number</parameter></paramdef>
<paramdef><parameter>position</parameter></paramdef>
<para>Splits the nucleotide chain indicated by <parameter>number</parameter> (0 being
the first nucleotide chain in the PDB file) after the residue indicated
by <parameter>position</parameter> (0 being the first residue of the chain).
The two chain fragments remain adjacent in the nucleotide chain
list, i.e. the numbers of all following nucleotide chains increase
by one.
</para>
</methoddescription>
<methoddescription><methoddef><method>joinPeptideChains</method></methoddef>
<paramdef><parameter>first</parameter></paramdef>
<paramdef><parameter>second</parameter></paramdef>
<para>Join the two peptide chains indicated by <parameter>first</parameter> and <parameter>second</parameter>
into one peptide chain. The new chain occupies the position
<parameter>first</parameter>; the chain at <parameter>second</parameter> is removed from the peptide
chain list.
</para>
</methoddescription>
<methoddescription><methoddef><method>joinNucleotideChains</method></methoddef>
<paramdef><parameter>first</parameter></paramdef>
<paramdef><parameter>second</parameter></paramdef>
<para>Join the two nucleotide chains indicated by <parameter>first</parameter> and <parameter>second</parameter>
into one nucleotide chain. The new chain occupies the position
<parameter>first</parameter>; the chain at <parameter>second</parameter> is removed from the nucleotide
chain list.
</para>
</methoddescription>
<methoddescription><methoddef><method>renumberAtoms</method></methoddef>
<void/><para>Renumber all atoms sequentially starting with 1.</para>
</methoddescription>
<methoddescription><methoddef><method>writeToFile</method></methoddef>
<paramdef><parameter>file</parameter></paramdef>
<para>Writes all objects to <parameter>file</parameter> (a PDBFile object or a
string containing a file name).
</para>
</methoddescription>
</classdescription>

</sect2>

<sect2 id="Module:Scientific.IO.TextFile" xreflabel="Scientific.IO.TextFile">
<title>Module Scientific.IO.TextFile</title>

<classdescription role="Python" id="Class:Scientific.IO.TextFile.TextFile" xreflabel="Scientific.IO.TextFile.TextFile">
<classdef><class>TextFile</class><classinfo>Text files with line iteration and transparent compression</classinfo></classdef>
<para>TextFile instances can be used like normal file objects
(i.e. by calling readline(), readlines(), and write()), but can
also be used as sequences of lines in for-loops.</para>
<para>TextFile objects also handle compression transparently. i.e. it is
possible to read lines from a compressed text file as if it were not
compressed.  Compression is deduced from the file name suffixes <literal role="Python">.Z</literal>
(compress/uncompress), <literal role="Python">.gz</literal> (gzip/gunzip), and <literal role="Python">.bz2</literal> (bzip2).</para>
<para>Finally, TextFile objects accept file names that start with <literal role="Python">~</literal> or
<literal role="Python">~user</literal> to indicate a home directory, as well as URLs (for reading only).</para>
<para>Constructor: TextFile(<parameter>filename</parameter>, <parameter>mode</parameter>=<literal role="Python">"r"</literal>), where <parameter>filename</parameter> is
the name of the file (or a URL) and <parameter>mode</parameter> is one of <literal role="Python">"r"</literal> (read),
<literal role="Python">"w"</literal> (write) or <literal role="Python">"a"</literal> (append, not supported for .Z files).
</para>
</classdescription>

</sect2>

</sect1>

<sect1 id="Module:Scientific.MPI" xreflabel="Scientific.MPI">
<title>Module Scientific.MPI</title>

<classdescription role="Python" id="Class:Scientific.MPI.MPICommunicator" xreflabel="Scientific.MPI.MPICommunicator">
<classdef><class>MPICommunicator</class><classinfo>MPI Communicator</classinfo></classdef>
<para>There is no constructor for MPI Communicator objects. The
default communicator is given by Scientific.MPI.world, and
other communicators can only be created by methods on an
existing communicator object.</para>
<para>A communicator object has two read-only attributes: <literal role="Python">rank</literal> is
an integer which indicates the rank of the current process in
the communicator, and <literal role="Python">size</literal> is an integer equal to the number
of processes that participate in the communicator.
</para>
<methoddescription><methoddef><method>duplicate</method></methoddef>
<void/><para>Returns a new communicator object with the same properties
as the original one.</para>
</methoddescription>
<methoddescription><methoddef><method>send</method></methoddef>
<paramdef><parameter>data</parameter></paramdef>
<paramdef><parameter>destination</parameter></paramdef>
<paramdef><parameter>tag</parameter></paramdef>
<para>Sends the contents of <parameter>data</parameter> (a string or any contiguous NumPy
array except for general object arrays) to the processor
whose rank is <parameter>destination</parameter>, using <parameter>tag</parameter> as an identifier.
</para>
</methoddescription>
<methoddescription><methoddef><method>nonblockingSend</method></methoddef>
<paramdef><parameter>data</parameter></paramdef>
<paramdef><parameter>destination</parameter></paramdef>
<paramdef><parameter>tag</parameter></paramdef>
<para>Sends the contents of <parameter>data</parameter> (a string or any contiguous NumPy
array except for general object arrays) to the processor
whose rank is <parameter>destination</parameter>, using <parameter>tag</parameter> as an identifier.
The send is nonblocking, i.e. the call returns immediately, even
if the destination process is not ready to receive.</para>
<para>The return value is an MPIRequest object.  It is used to
wait till the communication has actually happened.
</para>
</methoddescription>
<methoddescription><methoddef><method>receive</method></methoddef>
<paramdef><parameter>data</parameter></paramdef>
<paramdef><parameter>source</parameter><defaultvalue>None</defaultvalue></paramdef>
<paramdef><parameter>tag</parameter><defaultvalue>None</defaultvalue></paramdef>
<para>Receives an array from the process with rank <parameter>source</parameter>
with identifier <parameter>tag</parameter>. The default <parameter>source</parameter>=None means
that messages from any process are accepted. The value
of <parameter>data</parameter> can either be an array object, in which case it
must be contiguous and large enough to store the
incoming data; it must also have the correct shape.
Alternatively, <parameter>data</parameter> can be a string specifying
the data type (in practice, one would use Numeric.Int,
Numeric.Float, etc.). In the latter case, a new array
object is created to receive the data.</para>
<para>The return value is a tuple containing four elements:
the array containing the data, the source process rank
(an integer), the message tag (an integer), and the
number of elements that were received (an integer).
</para>
</methoddescription>
<methoddescription><methoddef><method>receiveString</method></methoddef>
<paramdef><parameter>source</parameter><defaultvalue>None</defaultvalue></paramdef>
<paramdef><parameter>tag</parameter><defaultvalue>None</defaultvalue></paramdef>
<para>Receives a string from the process with rank <parameter>source</parameter>
with identifier <parameter>tag</parameter>. The default <parameter>source</parameter>=None means
that messages from any process are accepted.</para>
<para>The return value is a tuple containing three elements:
the string containing the data, the source process rank
(an integer), and the message tag (an integer).
</para>
</methoddescription>
<methoddescription><methoddef><method>nonblockingReceive</method></methoddef>
<paramdef><parameter>data</parameter></paramdef>
<paramdef><parameter>source</parameter><defaultvalue>None</defaultvalue></paramdef>
<paramdef><parameter>tag</parameter><defaultvalue>None</defaultvalue></paramdef>
<para>Receives an array from the process with rank <parameter>source</parameter>
with identifier <parameter>tag</parameter>. The default <parameter>source</parameter>=None means
that messages from any process are accepted. The value
of <parameter>data</parameter> must be a contiguous array object, large enough
to store the incoming data; it must also have the correct
shape.  Unlike the blocking receive, the size of the array
must be known when the call is made, as nonblocking receives
of unknown quantities of data is not implemented.  For the
same reason there is no nonblocking_receiveString.</para>
<para>The return value is an MPIRequest object.  It is used to wait
until the data has arrived, and will give information about
the size, the source and the tag of the incoming message.
</para>
</methoddescription>
<methoddescription><methoddef><method>nonblockingProbe</method></methoddef>
<paramdef><parameter>source</parameter><defaultvalue>None</defaultvalue></paramdef>
<paramdef><parameter>tag</parameter><defaultvalue>None</defaultvalue></paramdef>
<para>Checks if a message from the process with rank <parameter>source</parameter>
and with identifier <parameter>tag</parameter> is available for immediate
reception. The return value is <literal role="Python">None</literal> if no message
is available, otherwise a <literal role="Python">(source, tag)</literal> tuple is
returned.
</para>
</methoddescription>
<methoddescription><methoddef><method>broadcast</method></methoddef>
<paramdef><parameter>array</parameter></paramdef>
<paramdef><parameter>root</parameter></paramdef>
<para>Sends data from the process with rank <parameter>root</parameter> to all
processes (including <parameter>root</parameter>). The parameter <parameter>array</parameter> can be
any contiguous NumPy array except for general object arrays.
On the process <parameter>root</parameter>, it holds the data to be sent. After
the call, the data in <parameter>array</parameter> is the same for all processors.
The shape and data type of <parameter>array</parameter> must be the same in
all processes.
</para>
</methoddescription>
<methoddescription><methoddef><method>share</method></methoddef>
<paramdef><parameter>send</parameter></paramdef>
<paramdef><parameter>receive</parameter></paramdef>
<para>Distributes data from each process to all other processes
in the communicator. The array <parameter>send</parameter> (any contiguous NumPy
array except for general object arrays) contains the data
to be sent by each process, the shape and data type must be
identical in all processes. The array <parameter>receive</parameter> must have
the same data type as <parameter>send</parameter> and one additional dimension
(the first one), whose length must be the number of processes
in the communicator. After the call, the value
of <parameter>receive[i]</parameter> is equal to the contents of the array <parameter>send</parameter>
in process i.
</para>
</methoddescription>
<methoddescription><methoddef><method>barrier</method></methoddef>
<void/><para>Waits until all processes in the communicator have
called the same method, then all processes continue.</para>
</methoddescription>
<methoddescription><methoddef><method>abort</method></methoddef>
<void/><para>Aborts all processes associated with the communicator.
For emergency use only.</para>
</methoddescription>
<methoddescription><methoddef><method>reduce</method></methoddef>
<paramdef><parameter>sendbuffer</parameter></paramdef>
<paramdef><parameter>receivebuffer</parameter></paramdef>
<paramdef><parameter>operation</parameter></paramdef>
<paramdef><parameter>root</parameter></paramdef>
<para>Combine data from all processes using <parameter>operation</parameter>, and
send the data to the process identified by <parameter>root</parameter>.</para>
<para><parameter>operation</parameter> is one of the operation objects defined globally
in the module: <literal role="Python">max</literal>, <literal role="Python">min</literal>, <literal role="Python">prod</literal>, <literal role="Python">sum</literal>, <literal role="Python">land</literal>, <literal role="Python">lor</literal>,
<literal role="Python">lxor</literal>, <literal role="Python">band</literal>, <literal role="Python">bor</literal>, bxor', <literal role="Python">maxloc</literal> and <literal role="Python">minloc</literal>.
</para>
</methoddescription>
<methoddescription><methoddef><method>allreduce</method></methoddef>
<paramdef><parameter>sendbuffer</parameter></paramdef>
<paramdef><parameter>receivebuffer</parameter></paramdef>
<paramdef><parameter>operation</parameter></paramdef>
<paramdef><parameter>root</parameter></paramdef>
<para>Combine data from all processes using <parameter>operation</parameter>, and
send the data to all processes in the communicator.</para>
<para><parameter>operation</parameter> is one of the operation objects defined globally
in the module: <literal role="Python">max</literal>, <literal role="Python">min</literal>, <literal role="Python">prod</literal>, <literal role="Python">sum</literal>, <literal role="Python">land</literal>, <literal role="Python">lor</literal>,
<literal role="Python">lxor</literal>, <literal role="Python">band</literal>, <literal role="Python">bor</literal>, bxor', <literal role="Python">maxloc</literal> and <literal role="Python">minloc</literal>.
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.MPI.MPIError" xreflabel="Scientific.MPI.MPIError">
<classdef><class>MPIError</class><classinfo>MPI call failed</classinfo></classdef>
</classdescription>

<classdescription role="Python" id="Class:Scientific.MPI.MPIRequest" xreflabel="Scientific.MPI.MPIRequest">
<classdef><class>MPIRequest</class><classinfo>MPI Request</classinfo></classdef>
<para>There is no constructor for MPI Request objects.  They are
returned by nonblocking send and receives, and are used to
query the status of the message.
</para>
<methoddescription><methoddef><method>wait</method></methoddef>
<void/><para>Waits till the communication has completed.  If the
operation was a nonblocking send, there is no return value.
If the operation was a nonblocking receive, the return
value is a tuple containing four elements: the array
containing the data, the source process rank (an integer),
the message tag (an integer), and the number of elements
that were received (an integer).
</para>
</methoddescription>
</classdescription>

<sect2 id="Module:Scientific.MPI.IO" xreflabel="Scientific.MPI.IO">
<title>Module Scientific.MPI.IO</title>

<classdescription role="Python" id="Class:Scientific.MPI.IO.LogFile" xreflabel="Scientific.MPI.IO.LogFile">
<classdef><class>LogFile</class><classinfo>File for logging events from all processes</classinfo></classdef>
<para>Constructor: LogFile(<parameter>filename</parameter>, <parameter>communicator</parameter>=None)</para>
<para><variablelist>
<varlistentry><term><parameter>filename</parameter></term>
<listitem><para>
the name of the file</para></listitem></varlistentry>
<varlistentry><term><parameter>communicator</parameter></term>
<listitem><para>
the communicator in which the file is accesible.
                  The default value of <literal role="Python">None</literal> means to use the
                  global world communicator, i.e. all possible
                  processes.</para></listitem></varlistentry>
</variablelist></para>
<para>The purpose of LogFile objects is to collect short text output from
all processors into a single file. All processes can write whatever
they want at any time; the date is simply stored locally.
After the file has been closed by all processes, the
data is sent to process 0, which then writes everything to one
text file, neatly separated by process rank number.</para>
<para>Note that due to the intermediate storage of the data, LogFile
objects should not be used for large amounts of data. Also
note that all data is lost if a process crashes before closing
the file.
</para>
<methoddescription><methoddef><method>write</method></methoddef>
<paramdef><parameter>string</parameter></paramdef>
<para>Write <parameter>string</parameter> to the file.</para>
</methoddescription>
<methoddescription><methoddef><method>flush</method></methoddef>
<void/><para>Write buffered data to the text file.</para>
</methoddescription>
<methoddescription><methoddef><method>close</method></methoddef>
<void/><para>Close the file, causing the real text file to be written.</para>
</methoddescription>
</classdescription>

</sect2>

</sect1>

<sect1 id="Module:Scientific.NumberDict" xreflabel="Scientific.NumberDict">
<title>Module Scientific.NumberDict</title>

<classdescription role="Python" id="Class:Scientific.NumberDict.NumberDict" xreflabel="Scientific.NumberDict.NumberDict">
<classdef><class>NumberDict</class><classinfo>Dictionary storing numerical values</classinfo></classdef>
<para>Constructor: NumberDict()</para>
<para>An instance of this class acts like an array of number with
generalized (non-integer) indices. A value of zero is assumed
for undefined entries. NumberDict instances support addition,
and subtraction with other NumberDict instances, and multiplication
and division by scalars.
</para>
</classdescription>

</sect1>

<sect1 id="Module:Scientific.Physics" xreflabel="Scientific.Physics">
<title>Module Scientific.Physics</title>

<sect2 id="Module:Scientific.Physics.PhysicalQuantities" xreflabel="Scientific.Physics.PhysicalQuantities">
<title>Module Scientific.Physics.PhysicalQuantities</title>

<para>Physical quantities with units.</para>
<para>This module provides a data type that represents a physical
quantity together with its unit. It is possible to add and
subtract these quantities if the units are compatible, and
a quantity can be converted to another compatible unit.
Multiplication, subtraction, and raising to integer powers
is allowed without restriction, and the result will have
the correct unit. A quantity can be raised to a non-integer
power only if the result can be represented by integer powers
of the base units.</para>
<para>The values of physical constants are taken from the 1986
recommended values from CODATA. Other conversion factors
(e.g. for British units) come from various sources. I can't
guarantee for the correctness of all entries in the unit
table, so use this at your own risk!
</para>
<classdescription role="Python" id="Class:Scientific.Physics.PhysicalQuantities.PhysicalQuantity" xreflabel="Scientific.Physics.PhysicalQuantities.PhysicalQuantity">
<classdef><class>PhysicalQuantity</class><classinfo>Physical quantity with units</classinfo></classdef>
<para>Constructor:</para>
<itemizedlist>
<listitem><para>
PhysicalQuantity(<parameter>value</parameter>, <parameter>unit</parameter>), where <parameter>value</parameter> is a number of
  arbitrary type and <parameter>unit</parameter> is a string containing the unit name.</para></listitem>
<listitem><para>
PhysicalQuantity(<parameter>string</parameter>), where <parameter>string</parameter> contains both the value
  and the unit. This form is provided to make interactive use more
  convenient.</para></listitem>
</itemizedlist>
<para>PhysicalQuantity instances allow addition, subtraction,
multiplication, and division with each other as well as
multiplication, division, and exponentiation with numbers.
Addition and subtraction check that the units of the two operands
are compatible and return the result in the units of the first
operand. A limited set of mathematical functions (from module
Numeric) is applicable as well:</para>
<para><variablelist>
<varlistentry><term>sqrt</term>
<listitem><para>
equivalent to exponentiation with 0.5.</para></listitem></varlistentry>
<varlistentry><term>sin, cos, tan</term>
<listitem><para>
applicable only to objects whose unit is compatible
                 with <literal role="Python">rad</literal>.
</para></listitem></varlistentry>
</variablelist></para>
<methoddescription><methoddef><method>convertToUnit</method></methoddef>
<paramdef><parameter>unit</parameter></paramdef>
<para>Changes the unit to <parameter>unit</parameter> and adjusts the value such that
the combination is equivalent. The new unit is by a string containing
its name. The new unit must be compatible with the previous unit
of the object.</para>
</methoddescription>
<methoddescription><methoddef><method>inUnitsOf</method></methoddef>
<paramdef><parameter>*units</parameter></paramdef>
<para>Returns one or more PhysicalQuantity objects that express
the same physical quantity in different units. The units are
specified by strings containing their names. The units must be
compatible with the unit of the object. If one unit is
specified, the return value is a single PhysicalObject. If
several units are specified, the return value is a tuple of
PhysicalObject instances with with one element per unit such
that the sum of all quantities in the tuple equals the the
original quantity and all the values except for the last one
are integers. This is used to convert to irregular unit
systems like hour/minute/second. The original object will not
be changed.
</para>
</methoddescription>
</classdescription>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Physics.PhysicalQuantities.isPhysicalQuantity" xreflabel="Scientific.Physics.PhysicalQuantities.isPhysicalQuantity" role="Python"><funcprototype><funcdef><function>isPhysicalQuantity</function></funcdef>
<paramdef><parameter>x</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns 1 if <parameter>x</parameter> is an instance of PhysicalQuantity.</para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.Physics.Potential" xreflabel="Scientific.Physics.Potential">
<title>Module Scientific.Physics.Potential</title>

<para>This module offers two strategies for automagically calculating the
gradients (and optionally force constants) of a potential energy
function (or any other function of vectors, for that matter).  The
more convenient strategy is to create an object of the class
PotentialWithGradients. It takes a regular Python function object
defining the potential energy and is itself a callable object
returning the energy and its gradients with respect to all arguments
that are vectors.</para>
<example><title>Example:</title><programlisting role="Python">
def _harmonic(k,r1,r2):
    dr = r2-r1
    return k*dr*dr
harmonic = PotentialWithGradients(_harmonic)
energy, gradients = harmonic(1., Vector(0,3,1), Vector(1,2,0))
print energy, gradients</programlisting><para>  prints</para>
<programlisting role="Python">
3.0
[Vector(-2.0,2.0,2.0), Vector(2.0,-2.0,-2.0)]</programlisting></example>
<example><title>The disadvantage of this procedure is that if one of the arguments is a
vector parameter, rather than a position, an unnecessary gradient will
be calculated. A more flexible method is to insert calls to two
function from this module into the definition of the energy
function. The first, DerivVectors(), is called to indicate which
vectors correspond to gradients, and the second, EnergyGradients(),
extracts energy and gradients from the result of the calculation.
The above example is therefore equivalent to</title><programlisting role="Python">
def harmonic(k, r1, r2):
    r1, r2 = DerivVectors(r1, r2)
    dr = r2-r1
    e = k*dr*dr
    return EnergyGradients(e,2)</programlisting></example>
<example><title>To include the force constant matrix, the above example has to be
modified as follows:</title><programlisting role="Python">
def _harmonic(k,r1,r2):
    dr = r2-r1
    return k*dr*dr
harmonic = PotentialWithGradientsAndForceConstants(_harmonic)
energy, gradients, force_constants = harmonic(1.,Vector(0,3,1),Vector(1,2,0))
print energy
print gradients
print force_constants</programlisting></example>
<para>The force constants are returned as a nested list representing a
matrix. This can easily be converted to an array for further
processing if the numerical extensions to Python are available.
</para>
</sect2>

</sect1>

<sect1 id="Module:Scientific.Signals" xreflabel="Scientific.Signals">
<title>Module Scientific.Signals</title>

<sect2 id="Module:Scientific.Signals.Models" xreflabel="Scientific.Signals.Models">
<title>Module Scientific.Signals.Models</title>

<classdescription role="Python" id="Class:Scientific.Signals.Models.AutoRegressiveModel" xreflabel="Scientific.Signals.Models.AutoRegressiveModel">
<classdef><class>AutoRegressiveModel</class><classinfo>Auto-regressive model for stochastic process</classinfo></classdef>
<para>This implementation uses the Burg algorithm to obtain the
coefficients of the AR model.</para>
<para>Constructor: AutoRegressiveModel(<parameter>order</parameter>, <parameter>data</parameter>, <parameter>delta_t</parameter>=1.)</para>
<para><variablelist>
<varlistentry><term><parameter>order</parameter></term>
<listitem><para>
the order of the model (an integer)</para></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter></term>
<listitem><para>
the time series (sequence of floats)</para></listitem></varlistentry>
<varlistentry><term><parameter>delta_t</parameter></term>
<listitem><para>
the sampling interval for the time series (default: 1.)
</para></listitem></varlistentry>
</variablelist></para>
<methoddescription><methoddef><method>predictStep</method></methoddef>
<void/><para>Return the next step in the series according to linear prediction.
The returned value is also appended internally to the current
trajectory, making it possible to call this method repeatedly
in order to obtain a sequence of predicted steps.
</para>
</methoddescription>
<methoddescription><methoddef><method>spectrum</method></methoddef>
<paramdef><parameter>omega</parameter></paramdef>
<para>Return the frequency spectrum of the process at the
angular frequencies <parameter>omega</parameter> (an array).
</para>
</methoddescription>
<methoddescription><methoddef><method>correlation</method></methoddef>
<paramdef><parameter>nsteps</parameter></paramdef>
<para>Return the autocorrelation function of the process (as estimated
from the AR model) up to <parameter>nsteps</parameter> times the sampling interval.
</para>
</methoddescription>
<methoddescription><methoddef><method>memoryFunction</method></methoddef>
<paramdef><parameter>nsteps</parameter></paramdef>
<para>Return the memory function corresponding to the autocorrelation
function of the process up to <parameter>nsteps</parameter> times the sampling interval.
</para>
</methoddescription>
<methoddescription><methoddef><method>frictionConstant</method></methoddef>
<void/><para>Return the friction constant (the integral over the memory function)
of the process.
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Signals.Models.AveragedAutoRegressiveModel" xreflabel="Scientific.Signals.Models.AveragedAutoRegressiveModel">
<classdef><class>AveragedAutoRegressiveModel</class><classinfo>Averaged auto-regressive model for stochastic process</classinfo></classdef>
<para>An averaged model is constructed by averaging the model
coefficients of several auto-regressive models of the same
order. An averaged model is created empty, then individual
models are added.</para>
<para>Constructor: AveragedAutoRegressiveModel(<parameter>order</parameter>, <parameter>delta_t</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>order</parameter></term>
<listitem><para>
the order of the model (an integer)</para></listitem></varlistentry>
<varlistentry><term><parameter>delta_t</parameter></term>
<listitem><para>
the sampling interval for the time series
</para></listitem></varlistentry>
</variablelist></para>
<methoddescription><methoddef><method>add</method></methoddef>
<paramdef><parameter>model</parameter></paramdef>
<paramdef><parameter>weight</parameter><defaultvalue>1</defaultvalue></paramdef>
<para>Add the coefficients of <parameter>model</parameter> to the average using <parameter>weight</parameter>.
</para>
</methoddescription>
</classdescription>

</sect2>

</sect1>

<sect1 id="Module:Scientific.Statistics" xreflabel="Scientific.Statistics">
<title>Module Scientific.Statistics</title>

<sect2>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Statistics.mean" xreflabel="Scientific.Statistics.mean" role="Python"><funcprototype><funcdef><function>mean</function></funcdef>
<paramdef><parameter>data</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns the mean (average value) of <parameter>data</parameter> (a sequence of numbers).</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Statistics.weightedMean" xreflabel="Scientific.Statistics.weightedMean" role="Python"><funcprototype><funcdef><function>weightedMean</function></funcdef>
<paramdef><parameter>data</parameter></paramdef>
<paramdef><parameter>sigma</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Weighted mean of a sequence of numbers with given standard deviations.</para>
<para><parameter>data</parameter> is a list of measurements,
<parameter>sigma</parameter> a list with corresponding standard deviations.</para>
<para>Returns weighted mean and corresponding standard deviation.
</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Statistics.variance" xreflabel="Scientific.Statistics.variance" role="Python"><funcprototype><funcdef><function>variance</function></funcdef>
<paramdef><parameter>data</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns the variance of <parameter>data</parameter> (a sequence of numbers).</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Statistics.standardDeviation" xreflabel="Scientific.Statistics.standardDeviation" role="Python"><funcprototype><funcdef><function>standardDeviation</function></funcdef>
<paramdef><parameter>data</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns the standard deviation of <parameter>data</parameter> (a sequence of numbers).</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Statistics.median" xreflabel="Scientific.Statistics.median" role="Python"><funcprototype><funcdef><function>median</function></funcdef>
<paramdef><parameter>data</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns the median of <parameter>data</parameter> (a sequence of numbers).</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Statistics.skewness" xreflabel="Scientific.Statistics.skewness" role="Python"><funcprototype><funcdef><function>skewness</function></funcdef>
<paramdef><parameter>data</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns the skewness of <parameter>data</parameter> (a sequence of numbers).</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Statistics.kurtosis" xreflabel="Scientific.Statistics.kurtosis" role="Python"><funcprototype><funcdef><function>kurtosis</function></funcdef>
<paramdef><parameter>data</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns the kurtosis of <parameter>data</parameter> (a sequence of numbers).</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Statistics.correlation" xreflabel="Scientific.Statistics.correlation" role="Python"><funcprototype><funcdef><function>correlation</function></funcdef>
<paramdef><parameter>data1</parameter></paramdef>
<paramdef><parameter>data2</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns the correlation coefficient between <parameter>data1</parameter> and <parameter>data2</parameter>,
which must have the same length.</para>
</listitem>
</itemizedlist>
</sect2>
<sect2 id="Module:Scientific.Statistics.Histogram" xreflabel="Scientific.Statistics.Histogram">
<title>Module Scientific.Statistics.Histogram</title>

<classdescription role="Python" id="Class:Scientific.Statistics.Histogram.Histogram" xreflabel="Scientific.Statistics.Histogram.Histogram">
<classdef><class>Histogram</class><classinfo>Histogram in one variable</classinfo></classdef>
<para>Constructor: Histogram(<parameter>data</parameter>, <parameter>bins</parameter>, <parameter>range</parameter>=None)</para>
<para><variablelist>
<varlistentry><term><parameter>data</parameter></term>
<listitem><para>
a sequence of data points</para></listitem></varlistentry>
<varlistentry><term><parameter>bins</parameter></term>
<listitem><para>
the number of bins into which the data is to be sorted</para></listitem></varlistentry>
<varlistentry><term><parameter>range</parameter></term>
<listitem><para>
a tuple of two values, specifying the lower and
           the upper end of the interval spanned by the bins.
           Any data point outside this interval will be ignored.
           If no range is given, the smallest and largest
           data values are used to define the interval.</para></listitem></varlistentry>
</variablelist></para>
<para>The bin index and the number of points in a bin can be obtained by
indexing the histogram with the bin number. Application of len()
yields the number of bins. A histogram thus behaves like a
sequence of bin index - bin count pairs.
</para>
<methoddescription><methoddef><method>addData</method></methoddef>
<paramdef><parameter>data</parameter></paramdef>
<para>Add the values in <parameter>data</parameter> (a sequence of numbers) to the
originally supplied data. Note that this does not affect the
default range of the histogram, which is fixed when the
histogram is created.
</para>
</methoddescription>
<methoddescription><methoddef><method>normalize</method></methoddef>
<paramdef><parameter>norm</parameter><defaultvalue>1.0</defaultvalue></paramdef>
<para>Scales all counts by the same factor such that their sum is <parameter>norm</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>normalizeArea</method></methoddef>
<paramdef><parameter>norm</parameter><defaultvalue>1.0</defaultvalue></paramdef>
<para>Scales all counts by the same factor such that the area under
the histogram is <parameter>norm</parameter>.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Statistics.Histogram.WeightedHistogram" xreflabel="Scientific.Statistics.Histogram.WeightedHistogram">
<classdef><class>WeightedHistogram</class><classinfo>Weighted histogram in one variable</classinfo></classdef>
<para>Constructor: WeightedHistogram(<parameter>data</parameter>, <parameter>weights</parameter>, <parameter>bins</parameter>, <parameter>range</parameter>=None)</para>
<para><variablelist>
<varlistentry><term><parameter>data</parameter></term>
<listitem><para>
a sequence of data points</para></listitem></varlistentry>
<varlistentry><term><parameter>weights</parameter></term>
<listitem><para>
a sequence of weights, same length as <parameter>data</parameter></para></listitem></varlistentry>
<varlistentry><term><parameter>bins</parameter></term>
<listitem><para>
the number of bins into which the data is to be sorted</para></listitem></varlistentry>
<varlistentry><term><parameter>range</parameter></term>
<listitem><para>
a tuple of two values, specifying the lower and
           the upper end of the interval spanned by the bins.
           Any data point outside this interval will be ignored.
           If no range is given, the smallest and largest
           data values are used to define the interval.</para></listitem></varlistentry>
</variablelist></para>
<para>In a weighted histogram, each point has a specific weight. If all
weights are one, the result is equivalent to a standard histogram.
The bin index and the number of points in a bin can be obtained by
indexing the histogram with the bin number. Application of len()
yields the number of bins. A histogram thus behaves like a
sequence of bin index - bin count pairs.
</para>
<methoddescription><methoddef><method>addData</method></methoddef>
<paramdef><parameter>data</parameter></paramdef>
<paramdef><parameter>weights</parameter></paramdef>
<para>Add the values in <parameter>data</parameter> (a sequence of numbers) with the
given <parameter>weights</parameter> to the originally supplied data. Note that
this does not affect the default range of the histogram, which
is fixed when the histogram is created.
</para>
</methoddescription>
</classdescription>

</sect2>

</sect1>

<sect1 id="Module:Scientific.Threading" xreflabel="Scientific.Threading">
<title>Module Scientific.Threading</title>

<sect2 id="Module:Scientific.Threading.TaskManager" xreflabel="Scientific.Threading.TaskManager">
<title>Module Scientific.Threading.TaskManager</title>

<classdescription role="Python" id="Class:Scientific.Threading.TaskManager.TaskManager" xreflabel="Scientific.Threading.TaskManager.TaskManager">
<classdef><class>TaskManager</class><classinfo>Parallel task manager for shared-memory multiprocessor machines</classinfo></classdef>
<para>This class provides a rather simple way to profit from
shared-memory multiprocessor machines by running several tasks
in parallel. The calling program decides how many execution threads
should run at any given time, and then feeds compute tasks to
the task manager, who runs them as soon as possible without exceeding
the maximum number of threads.</para>
<para>The major limitation of this approach lies in Python's Global
Interpreter Lock. This effectively means that no more than one
Python thread can run at the same time. Consequently, parallelization
can only be achieved if the tasks to be parallelized spend
significant time in C extension modules that release the Global
Interpreter Lock.</para>
<para>Constructor: TaskManager(<parameter>nthreads</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>nthreads</parameter></term>
<listitem><para>
the maximum number of compute threads that should
              run in parallel. Note: This does not include the
              main thread which generated and feeds the task
              manager!
</para></listitem></varlistentry>
</variablelist></para>
<methoddescription><methoddef><method>runTask</method></methoddef>
<paramdef><parameter>function</parameter></paramdef>
<paramdef><parameter>args</parameter></paramdef>
<para>Add a task defined by <parameter>function</parameter>. This must be a callable
object, which will be called exactly once. The arguments of the
call are the elements of the tuple <parameter>args</parameter> plus one additional
argument which is a lock object. The task can use this lock
object in order to get temporary exclusive acces to data
shared with other tasks, e.g. a list in which to accumulate
results.</para>
</methoddescription>
<methoddescription><methoddef><method>terminate</method></methoddef>
<void/><para>Wait until all tasks have finished.</para>
</methoddescription>
</classdescription>

</sect2>

</sect1>

<sect1 id="Module:Scientific.TkWidgets" xreflabel="Scientific.TkWidgets">
<title>Module Scientific.TkWidgets</title>

<classdescription role="Python" id="Class:Scientific.TkWidgets.FilenameEntry" xreflabel="Scientific.TkWidgets.FilenameEntry">
<classdef><class>FilenameEntry</class><classinfo>Filename entry widget</classinfo></classdef>
<para>Constructor: FilenameEntry(<parameter>master</parameter>, <parameter>text</parameter>, <parameter>pattern</parameter>,
                           <parameter>must_exist_flag</parameter>=1)</para>
<para><variablelist>
<varlistentry><term><parameter>master</parameter></term>
<listitem><para>
the master widget</para></listitem></varlistentry>
<varlistentry><term><parameter>text</parameter></term>
<listitem><para>
the label in front of the filename box</para></listitem></varlistentry>
<varlistentry><term><parameter>pattern</parameter></term>
<listitem><para>
the filename matching pattern that determines the
             file list in the file selection dialog</para></listitem></varlistentry>
<varlistentry><term><parameter>must_exists_flag</parameter></term>
<listitem><para>
allow only names of existing files</para></listitem></varlistentry>
</variablelist></para>
<para>A FilenameEntry widget consists of three parts: an identifying
label, a text entry field for the filename, and a button labelled
<literal role="Python">browse</literal> which call a file selection dialog box for picking a file
name.
</para>
<methoddescription><methoddef><method>get</method></methoddef>
<void/><para>Return the current filename. If <parameter>must_exist_flag</parameter> is true,
verify that the name refers to an existing file.
Otherwise an error message is displayed and a ValueError is raised.
</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.FloatEntry" xreflabel="Scientific.TkWidgets.FloatEntry">
<classdef><class>FloatEntry</class><classinfo>An entry field for float numbers</classinfo></classdef>
<para>Constructor: FloatEntry(<parameter>master</parameter>, <parameter>text</parameter>, <parameter>initial</parameter>=None,
                        <parameter>lower</parameter>=None, <parameter>upper</parameter>=None)</para>
<para><variablelist>
<varlistentry><term><parameter>master</parameter></term>
<listitem><para>
the master widget</para></listitem></varlistentry>
<varlistentry><term><parameter>text</parameter></term>
<listitem><para>
the label in front of the entry field</para></listitem></varlistentry>
<varlistentry><term><parameter>initial</parameter></term>
<listitem><para>
an optional initial value (default: blank field)</para></listitem></varlistentry>
<varlistentry><term><parameter>upper</parameter></term>
<listitem><para>
an optional upper limit for the value</para></listitem></varlistentry>
<varlistentry><term><parameter>lower</parameter></term>
<listitem><para>
an optional lower limit for the value</para></listitem></varlistentry>
</variablelist></para>
<para>A FloatEntry widget consists of a label followed by a text entry
field. 
</para>
<methoddescription><methoddef><method>set</method></methoddef>
<paramdef><parameter>value</parameter></paramdef>
<para>Set the value to <parameter>value</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>get</method></methoddef>
<void/><para>Return the current value, verifying that it is a number
and between the specified limits. Otherwise an error message
is displayed and a ValueError is raised.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.IntEntry" xreflabel="Scientific.TkWidgets.IntEntry">
<classdef><class>IntEntry</class><classinfo>An entry field for integer numbers</classinfo></classdef>
<para>Constructor: IntEntry(<parameter>master</parameter>, <parameter>text</parameter>, <parameter>initial</parameter>=None,
                      <parameter>lower</parameter>=None, <parameter>upper</parameter>=None)</para>
<para><variablelist>
<varlistentry><term><parameter>master</parameter></term>
<listitem><para>
the master widget</para></listitem></varlistentry>
<varlistentry><term><parameter>text</parameter></term>
<listitem><para>
the label in front of the entry field</para></listitem></varlistentry>
<varlistentry><term><parameter>initial</parameter></term>
<listitem><para>
an optional initial value (default: blank field)</para></listitem></varlistentry>
<varlistentry><term><parameter>upper</parameter></term>
<listitem><para>
an optional upper limit for the value</para></listitem></varlistentry>
<varlistentry><term><parameter>lower</parameter></term>
<listitem><para>
an optional lower limit for the value</para></listitem></varlistentry>
</variablelist></para>
<para>A IntEntry widget consists of a label followed by a text entry
field. 
</para>
<methoddescription><methoddef><method>get</method></methoddef>
<void/><para>Return the current value, verifying that it is an integer
and between the specified limits. Otherwise an error message
is displayed and a ValueError is raised.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.ButtonBar" xreflabel="Scientific.TkWidgets.ButtonBar">
<classdef><class>ButtonBar</class><classinfo>A horizontal array of buttons</classinfo></classdef>
<para>Constructor: ButtonBar(<parameter>master</parameter>, <parameter>left_button_list</parameter>, <parameter>right_button_list</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>master</parameter></term>
<listitem><para>
the master widget</para></listitem></varlistentry>
<varlistentry><term><parameter>left_button_list</parameter></term>
<listitem><para>
a list of (text, action) tuples specifying the
                      buttons on the left-hand side of the button bar</para></listitem></varlistentry>
<varlistentry><term><parameter>right_button_list</parameter></term>
<listitem><para>
a list of (text, action) tuples specifying the
                       buttons on the right-hand side of the button bar
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.StatusBar" xreflabel="Scientific.TkWidgets.StatusBar">
<classdef><class>StatusBar</class><classinfo>A status bar</classinfo></classdef>
<para>Constructor: StatusBar(<parameter>master</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>master</parameter></term>
<listitem><para>
the master widget</para></listitem></varlistentry>
</variablelist></para>
<para>A status bar can be used to inform the user about the status of an
ongoing calculation. A message can be displayed with set() and
removed with clear(). In both cases, the StatusBar object makes
sure that the change takes place immediately. While a message
is being displayed, the cursor form is changed to a watch.
</para>
</classdescription>

<sect2 id="Module:Scientific.TkWidgets.TkPlotCanvas" xreflabel="Scientific.TkWidgets.TkPlotCanvas">
<title>Module Scientific.TkWidgets.TkPlotCanvas</title>

<classdescription role="Python" id="Class:Scientific.TkWidgets.TkPlotCanvas.PolyLine" xreflabel="Scientific.TkWidgets.TkPlotCanvas.PolyLine">
<classdef><class>PolyLine</class><classinfo>Multiple connected lines</classinfo></classdef>
<para>Constructor: PolyLine(<parameter>points</parameter>, **|attr|)</para>
<para><variablelist>
<varlistentry><term><parameter>points</parameter></term>
<listitem><para>
any sequence of (x, y) number pairs</para></listitem></varlistentry>
<varlistentry><term><parameter>attr</parameter></term>
<listitem><para>
line attributes specified by keyword arguments:<itemizedlist>
<listitem><para>
<literal role="Python">width</literal>: the line width (default: 1)
</para></listitem>
<listitem><para>
<literal role="Python">color</literal>: a string whose value is one of the color names defined in Tk
             (default: "black")
</para></listitem>
<listitem><para>
<literal role="Python">stipple</literal>: a string whose value is the name of a bitmap defined in Tk,
               or <literal role="Python">None</literal> for no bitmap (default: <literal role="Python">None</literal>)
</para></listitem>
</itemizedlist>
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.TkPlotCanvas.VerticalLine" xreflabel="Scientific.TkWidgets.TkPlotCanvas.VerticalLine">
<classdef><class>VerticalLine</class><classinfo>A vertical line</classinfo></classdef>
<para>Constructor: VerticalLine(<parameter>xpos</parameter>, **|attr|)</para>
<para><variablelist>
<varlistentry><term><parameter>xpos</parameter></term>
<listitem><para>
the x coordinate of the line</para></listitem></varlistentry>
<varlistentry><term><parameter>attr</parameter></term>
<listitem><para>
line attributes specified by keyword arguments:<itemizedlist>
<listitem><para>
<literal role="Python">width</literal>: the line width (default: 1)
</para></listitem>
<listitem><para>
<literal role="Python">color</literal>: a string whose value is one of the color names defined in Tk
             (default: "black")
</para></listitem>
<listitem><para>
<literal role="Python">stipple</literal>: a string whose value is the name of a bitmap defined in Tk,
               or <literal role="Python">None</literal> for no bitmap (default: <literal role="Python">None</literal>)
</para></listitem>
</itemizedlist>
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.TkPlotCanvas.HorizontalLine" xreflabel="Scientific.TkWidgets.TkPlotCanvas.HorizontalLine">
<classdef><class>HorizontalLine</class><classinfo>A horizontal line</classinfo></classdef>
<para>Constructor: HorizontalLine(<parameter>ypos</parameter>, **|attr|)</para>
<para><variablelist>
<varlistentry><term><parameter>ypos</parameter></term>
<listitem><para>
the y coordinate of the line</para></listitem></varlistentry>
<varlistentry><term><parameter>attr</parameter></term>
<listitem><para>
line attributes specified by keyword arguments:<itemizedlist>
<listitem><para>
<literal role="Python">width</literal>: the line width (default: 1)
</para></listitem>
<listitem><para>
<literal role="Python">color</literal>: a string whose value is one of the color names defined in Tk
             (default: "black")
</para></listitem>
<listitem><para>
<literal role="Python">stipple</literal>: a string whose value is the name of a bitmap defined in Tk,
               or <literal role="Python">None</literal> for no bitmap (default: <literal role="Python">None</literal>)
</para></listitem>
</itemizedlist>
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.TkPlotCanvas.PolyMarker" xreflabel="Scientific.TkWidgets.TkPlotCanvas.PolyMarker">
<classdef><class>PolyMarker</class><classinfo>Series of markers</classinfo></classdef>
<para>Constructor: PolyPoints(<parameter>points</parameter>, **|attr|)</para>
<para><variablelist>
<varlistentry><term><parameter>points</parameter></term>
<listitem><para>
any sequence of (x, y) number pairs</para></listitem></varlistentry>
</variablelist></para>
<para><parameter>attr</parameter> marker attributes specified by keyword arguments:<itemizedlist>
<listitem><para>
<literal role="Python">width</literal>: the line width for drawing the marker (default: 1)
</para></listitem>
<listitem><para>
<literal role="Python">color</literal>: a string whose value is one of the color names defined in Tk,
           defines the color of the line forming the marker
           (default: black)
</para></listitem>
<listitem><para>
<literal role="Python">fillcolor</literal>: a string whose value is one of the color names defined
               in Tk, defines the color of the interior of the marker
               (default: black)
</para></listitem>
<listitem><para>
<literal role="Python">marker</literal>: one of <literal role="Python">circle</literal> (default), <literal role="Python">dot</literal>, <literal role="Python">square</literal>, <literal role="Python">triangle</literal>,
            <literal role="Python">triangle_down</literal>, <literal role="Python">cross</literal>, <literal role="Python">plus</literal>
</para></listitem>
</itemizedlist>
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.TkPlotCanvas.PlotGraphics" xreflabel="Scientific.TkWidgets.TkPlotCanvas.PlotGraphics">
<classdef><class>PlotGraphics</class><classinfo>Compound graphics object</classinfo></classdef>
<para>Constructor: PlotGraphics(<parameter>objects</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>objects</parameter></term>
<listitem><para>
a list whose elements can be instances of the classes
             PolyLine, PolyMarker, and PlotGraphics.
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.TkPlotCanvas.PlotCanvas" xreflabel="Scientific.TkWidgets.TkPlotCanvas.PlotCanvas">
<classdef><class>PlotCanvas</class><classinfo>Tk plot widget</classinfo></classdef>
<para>Constructor: PlotCanvas(<parameter>master</parameter>, <parameter>width</parameter>, <parameter>height</parameter>, **|attributes|).</para>
<para>The arguments have the same meaning as for a standard Tk canvas.
The default background color is white and the default font is
Helvetica at 10 points.</para>
<para>PlotCanvas objects support all operations of Tk widgets.</para>
<para>There are two attributes in addition to the standard Tk attributes:</para>
<para><variablelist>
<varlistentry><term><parameter>zoom</parameter></term>
<listitem><para>
a logical variable that indicates whether interactive
          zooming (using the left mouse button) is enabled; the
          default is 0 (no zoom)</para></listitem></varlistentry>
<varlistentry><term><parameter>select</parameter></term>
<listitem><para>
enables the user to select a range along the x axis
            by dragging the mouse (with the left button pressed)
            in the area <emphasis>under</emphasis> the x axis. If <parameter>select</parameter> is 0,
            no selection is possible. Otherwise the value of <parameter>select</parameter>
            must be a callable object that is called whenever the
            selection changes, with a single argument that can be
            None (no selection) or a tuple containing two
            x values.
</para></listitem></varlistentry>
</variablelist></para>
<methoddescription><methoddef><method>draw</method></methoddef>
<paramdef><parameter>graphics</parameter></paramdef>
<paramdef><parameter>xaxis</parameter><defaultvalue>None</defaultvalue></paramdef>
<paramdef><parameter>yaxis</parameter><defaultvalue>None</defaultvalue></paramdef>
<para>Draws the graphics object <parameter>graphics</parameter>, which can be
a PolyLine, PolyMarker, or PlotGraphics object. The
arguments <parameter>xaxis</parameter> and <parameter>yaxis</parameter> specify how axes are
drawn: <literal role="Python">None</literal> means that no axis is drawn and the graphics
objects are scaled to fill the canvas optimally. <literal role="Python">"automatic"</literal>
means that the axis is drawn and a suitable value range is
determined automatically. A sequence of two numbers means
that the axis is drawn and the value range is the interval
specified by the two numbers.
</para>
</methoddescription>
<methoddescription><methoddef><method>clear</method></methoddef>
<void/><para>Clears the canvas.</para>
</methoddescription>
<methoddescription><methoddef><method>redraw</method></methoddef>
<void/><para>Redraws the last canvas contents.</para>
</methoddescription>
<methoddescription><methoddef><method>select</method></methoddef>
<paramdef><parameter>range</parameter></paramdef>
<para>Shows the given <parameter>range</parameter> as highlighted. <parameter>range</parameter> can be
None (no selection) or a sequence of two values on the
x-axis.</para>
</methoddescription>
</classdescription>

</sect2>

<sect2 id="Module:Scientific.TkWidgets.TkVisualizationCanvas" xreflabel="Scientific.TkWidgets.TkVisualizationCanvas">
<title>Module Scientific.TkWidgets.TkVisualizationCanvas</title>

<classdescription role="Python" id="Class:Scientific.TkWidgets.TkVisualizationCanvas.PolyLine3D" xreflabel="Scientific.TkWidgets.TkVisualizationCanvas.PolyLine3D">
<classdef><class>PolyLine3D</class><classinfo>Multiple connected lines</classinfo></classdef>
<para>Constructor: PolyLine(<parameter>points</parameter>, **|attr|), where <parameter>points</parameter> is
any sequence of (x, y, z) number triples and <parameter>attr</parameter> stands for line
attributes specified by keyword arguments, which are
<literal role="Python">width</literal> (an integer) and <literal role="Python">color</literal> (a string whose value is one of
the color names defined in Tk). The default is a black line
of width 1.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.TkVisualizationCanvas.VisualizationGraphics" xreflabel="Scientific.TkWidgets.TkVisualizationCanvas.VisualizationGraphics">
<classdef><class>VisualizationGraphics</class><classinfo>Compound graphics object</classinfo></classdef>
<para>Constructor: VisualizationGraphics(<parameter>objects</parameter>), where <parameter>objects</parameter> is a list
whose elements can be instances of the classes PolyLine3D and
VisualizationGraphics.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.TkWidgets.TkVisualizationCanvas.VisualizationCanvas" xreflabel="Scientific.TkWidgets.TkVisualizationCanvas.VisualizationCanvas">
<classdef><class>VisualizationCanvas</class><classinfo>Tk visualization widget</classinfo></classdef>
<para>Constructor: VisualizationCanvas(<parameter>master</parameter>, <parameter>width</parameter>, <parameter>height</parameter>,
                                 **|attributes|).
The arguments have the same meaning as for a standard Tk canvas.
The default background color is white and the default font is
Helvetica at 10 points.</para>
<para>VisualizationCanvas objects support all operations of Tk widgets.</para>
<para>Interactive manipulation of the display is possible with
click-and-drag operations. The left mouse button rotates the
objects, the middle button translates it, and the right button
scales it up or down.
</para>
<methoddescription><methoddef><method>draw</method></methoddef>
<paramdef><parameter>graphics</parameter></paramdef>
<para>Draws the graphics object <parameter>graphics</parameter>, which can be
a PolyLine3D or a VisualizationGraphics object.</para>
</methoddescription>
<methoddescription><methoddef><method>clear</method></methoddef>
<paramdef><parameter>keepscale</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Clears the canvas.</para>
</methoddescription>
</classdescription>

</sect2>

</sect1>

<sect1 id="Module:Scientific.Visualization" xreflabel="Scientific.Visualization">
<title>Module Scientific.Visualization</title>

<para>The modules in this subpackage provide visualization of 3D objects
using different backends (VRML, VMD, VPython), but with an almost
identical interface. It is thus possible to write generic 3D graphics
code in which the backend can be changed by modifying a single line
of code.</para>
<para>The intended application of these modules is scientific visualization.
Many sophisticated 3D objects are therefore absent, as are complex
surface definitions such as textures.
</para>
<sect2 id="Module:Scientific.Visualization.Color" xreflabel="Scientific.Visualization.Color">
<title>Module Scientific.Visualization.Color</title>

<para>This module provides color definitions that are used in the modules
VRML, VRML2, and VMD.
</para>
<classdescription role="Python" id="Class:Scientific.Visualization.Color.Color" xreflabel="Scientific.Visualization.Color.Color">
<classdef><class>Color</class><classinfo>RGB Color specification</classinfo></classdef>
<para>Constructor: Color(<parameter>rgb</parameter>), where <parameter>rgb</parameter> is a sequence of three numbers
between zero and one, specifying the red, green, and blue intensities.</para>
<para>Color objects can be added and multiplied with scalars.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.Color.ColorScale" xreflabel="Scientific.Visualization.Color.ColorScale">
<classdef><class>ColorScale</class><classinfo>Mapping of a number interval to a color range</classinfo></classdef>
<para>Constructor: ColorScale(<parameter>range</parameter>), where <parameter>range</parameter> can be a tuple of
two numbers (the center of the interval and its width), or a
single number specifying the widths for a default center of zero.</para>
<para>Evaluation: colorscale(<parameter>number</parameter>) returns the Color object
corresponding to <parameter>number</parameter>. If <parameter>number</parameter> is outside the
predefined interval, the closest extreme value of the interval
is used.</para>
<para>The color scale is blue - green - yellow - orange - red.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.Color.SymmetricColorScale" xreflabel="Scientific.Visualization.Color.SymmetricColorScale">
<classdef><class>SymmetricColorScale</class><classinfo>Mapping of a symmetric number interval to a color range</classinfo></classdef>
<para>Constructor: SymmetricColorScale(<parameter>range</parameter>), where <parameter>range</parameter> is a
single number defining the interval, which is -|range| to <parameter>range</parameter>.</para>
<para>Evaluation: colorscale(<parameter>number</parameter>) returns the Color object
corresponding to <parameter>number</parameter>. If <parameter>number</parameter> is outside the
predefined interval, the closest extreme value of the interval
is used.</para>
<para>The colors are red for negative numbers and green for positive
numbers, with a color intensity proportional to the absolute
value of the argument.
</para>
</classdescription>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Visualization.Color.ColorByName" xreflabel="Scientific.Visualization.Color.ColorByName" role="Python"><funcprototype><funcdef><function>ColorByName</function></funcdef>
<paramdef><parameter>name</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns a Color object corresponding to <parameter>name</parameter>. The known names
are black, white, grey, red, green, blue, yellow, magenta, cyan,
orange, violet, olive, and brown. Any color can be prefixed by
"light " or "dark " to yield a variant.
</para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.Visualization.VMD" xreflabel="Scientific.Visualization.VMD">
<title>Module Scientific.Visualization.VMD</title>

<para>This module provides definitions of simple 3D graphics objects and
scenes containing them, in a form that can be fed to the molecular
visualization program VMD. Scenes can either be written as VMD script
files, or visualized directly by running VMD.</para>
<example><title>There are a few attributes that are common to all graphics objects:</title><para><variablelist>
<varlistentry><term>material</term>
<listitem><para>
a Material object defining color and surface properties</para></listitem></varlistentry>
<varlistentry><term>comment</term>
<listitem><para>
a comment string that will be written to the VRML file</para></listitem></varlistentry>
<varlistentry><term>reuse</term>
<listitem><para>
a boolean flag (defaulting to false). If set to one,
           the object may share its VRML definition with other
           objects. This reduces the size of the VRML file, but
           can yield surprising side effects in some cases.</para></listitem></varlistentry>
</variablelist></para>
</example>
<para>This module is almost compatible with the modules VRML and VRML2, which
provide visualization by VRML browsers. There is no Polygon objects,
and the only material attribute supported is diffuse_color. Note
also that loading a scene with many cubes into VMD is very slow, because
each cube is represented by 12 individual triangles.</para>
<para>Example:</para>
<programlisting role="Python">
from VMD import *
scene = Scene([])
scale = ColorScale(10.)
for x in range(11):
    color = scale(x)
    scene.addObject(Cube(Vector(x, 0., 0.), 0.2,
                         material=Material(diffuse_color = color)))
scene.view()
</programlisting><classdescription role="Python" id="Class:Scientific.Visualization.VMD.Scene" xreflabel="Scientific.Visualization.VMD.Scene">
<classdef><class>Scene</class><classinfo>VMD scene</classinfo></classdef>
<para>A VMD scene is a collection of graphics objects that can be
written to a VMD script file or fed directly to VMD.</para>
<para>Constructor: Scene(<parameter>objects</parameter>=None, **|options|)</para>
<para><variablelist>
<varlistentry><term><parameter>objects</parameter></term>
<listitem><para>
a list of graphics objects or <literal role="Python">None</literal> for an empty scene</para></listitem></varlistentry>
<varlistentry><term><parameter>options</parameter></term>
<listitem><para>
options as keyword arguments. The only option available
             is "scale", whose value must be a positive number which
             specifies a scale factor applied to all coordinates of
             geometrical objects <emphasis>except</emphasis> for molecule objects, which
             cannot be scaled.
</para></listitem></varlistentry>
</variablelist></para>
<methoddescription><methoddef><method>addObject</method></methoddef>
<paramdef><parameter>object</parameter></paramdef>
<para>Adds <parameter>object</parameter> to the list of graphics objects.</para>
</methoddescription>
<methoddescription><methoddef><method>writeToFile</method></methoddef>
<paramdef><parameter>filename</parameter></paramdef>
<paramdef><parameter>delete</parameter><defaultvalue>0</defaultvalue></paramdef>
<para>Writes the scene to a VRML file with name <parameter>filename</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>view</method></methoddef>
<void/><para>Start VMD for the scene.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VMD.Molecules" xreflabel="Scientific.Visualization.VMD.Molecules">
<classdef><class>Molecules</class><classinfo>Molecules from a PDB file</classinfo></classdef>
<para>Constructor: Molecules(<parameter>pdb_file</parameter>)
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VMD.Sphere" xreflabel="Scientific.Visualization.VMD.Sphere">
<classdef><class>Sphere</class><classinfo>Sphere</classinfo></classdef>
<para>Constructor: Sphere(<parameter>center</parameter>, <parameter>radius</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>center</parameter></term>
<listitem><para>
the center of the sphere (a vector)</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the sphere radius (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VMD.Cube" xreflabel="Scientific.Visualization.VMD.Cube">
<classdef><class>Cube</class><classinfo>Cube</classinfo></classdef>
<para>Constructor: Cube(<parameter>center</parameter>, <parameter>edge</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>center</parameter></term>
<listitem><para>
the center of the cube (a vector)</para></listitem></varlistentry>
<varlistentry><term><parameter>edge</parameter></term>
<listitem><para>
the length of an edge  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute</para></listitem></varlistentry>
</variablelist></para>
<para>The edges of a cube are always parallel to the coordinate axes.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VMD.Cylinder" xreflabel="Scientific.Visualization.VMD.Cylinder">
<classdef><class>Cylinder</class><classinfo>Cylinder</classinfo></classdef>
<para>Constructor: Cylinder(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>,
                      <parameter>faces</parameter>=<literal role="Python">(1, 1, 1)</literal>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the cylinder axis (vectors)</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute</para></listitem></varlistentry>
<varlistentry><term><parameter>faces</parameter></term>
<listitem><para>
a sequence of three boolean flags, corresponding to
           the cylinder hull and the two circular end pieces,
           specifying for each of these parts whether it is visible
           or not.
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VMD.Cone" xreflabel="Scientific.Visualization.VMD.Cone">
<classdef><class>Cone</class><classinfo>Cone</classinfo></classdef>
<para>Constructor: Cone(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>, <parameter>face</parameter>=<literal role="Python">1</literal>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the cylinder axis (vectors).
                      <parameter>point1</parameter> is the tip of the cone.</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute</para></listitem></varlistentry>
<varlistentry><term><parameter>face</parameter></term>
<listitem><para>
a boolean flag, specifying if the circular bottom is visible
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VMD.Line" xreflabel="Scientific.Visualization.VMD.Line">
<classdef><class>Line</class><classinfo>Line</classinfo></classdef>
<para>Constructor: Line(<parameter>point1</parameter>, <parameter>point2</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the line (vectors)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VMD.Arrow" xreflabel="Scientific.Visualization.VMD.Arrow">
<classdef><class>Arrow</class><classinfo>Arrow</classinfo></classdef>
<para>An arrow consists of a cylinder and a cone.</para>
<para>Constructor: Arrow(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the arrow (vectors).
                      <parameter>point2</parameter> defines the tip of the arrow.</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius of the arrow shaft (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VMD.Material" xreflabel="Scientific.Visualization.VMD.Material">
<classdef><class>Material</class><classinfo>Material for graphics objects</classinfo></classdef>
<para>A material defines the color and surface properties of an object.</para>
<para>Constructor: Material(**|attributes|)</para>
<para>The accepted attributes are "ambient_color", "diffuse_color",
"specular_color", "emissive_color", "shininess", and "transparency".
Only "diffuse_color" is used, the others are permitted for compatibility
with the VRML modules.
</para>
</classdescription>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Visualization.VMD.DiffuseMaterial" xreflabel="Scientific.Visualization.VMD.DiffuseMaterial" role="Python"><funcprototype><funcdef><function>DiffuseMaterial</function></funcdef>
<paramdef><parameter>color</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns a material with the <literal role="Python">diffuse color</literal> attribute set to <parameter>color</parameter>.</para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.Visualization.VPython" xreflabel="Scientific.Visualization.VPython">
<title>Module Scientific.Visualization.VPython</title>

<classdescription role="Python" id="Class:Scientific.Visualization.VPython.Scene" xreflabel="Scientific.Visualization.VPython.Scene">
<classdef><class>Scene</class><classinfo>VPython scene</classinfo></classdef>
<para>A VPython scene is a collection of graphics objects that can be
shown in a VPython window. When the "view" method is called,
a new window is created and the graphics objects are displayed
in it.</para>
<para>Constructor: Scene(<parameter>objects</parameter>=None, **|options|)</para>
<para><variablelist>
<varlistentry><term><parameter>objects</parameter></term>
<listitem><para>
a list of graphics objects or <literal role="Python">None</literal> for an empty scene</para></listitem></varlistentry>
<varlistentry><term><parameter>options</parameter></term>
<listitem><para>
options as keyword arguments: "title" (the window title,
             default: "VPython scene"),  "width" (the window width,
             default: 300), "height" (the window height, default: 300),
             "background" (the background color, default: <literal role="Python">black</literal>)
</para></listitem></varlistentry>
</variablelist></para>
<methoddescription><methoddef><method>addObject</method></methoddef>
<paramdef><parameter>object</parameter></paramdef>
<para>Adds <parameter>object</parameter> to the list of graphics objects.</para>
</methoddescription>
<methoddescription><methoddef><method>view</method></methoddef>
<void/><para>Open a VPython window for the scene.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VPython.Sphere" xreflabel="Scientific.Visualization.VPython.Sphere">
<classdef><class>Sphere</class><classinfo>Sphere</classinfo></classdef>
<para>Constructor: Sphere(<parameter>center</parameter>, <parameter>radius</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>center</parameter></term>
<listitem><para>
the center of the sphere (a vector)</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the sphere radius (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VPython.Cube" xreflabel="Scientific.Visualization.VPython.Cube">
<classdef><class>Cube</class><classinfo>Cube</classinfo></classdef>
<para>Constructor: Cube(<parameter>center</parameter>, <parameter>edge</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>center</parameter></term>
<listitem><para>
the center of the cube (a vector)</para></listitem></varlistentry>
<varlistentry><term><parameter>edge</parameter></term>
<listitem><para>
the length of an edge  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute</para></listitem></varlistentry>
</variablelist></para>
<para>The edges of a cube are always parallel to the coordinate axes.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VPython.Cylinder" xreflabel="Scientific.Visualization.VPython.Cylinder">
<classdef><class>Cylinder</class><classinfo>Cylinder</classinfo></classdef>
<para>Constructor: Cylinder(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the cylinder axis (vectors)</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VPython.Arrow" xreflabel="Scientific.Visualization.VPython.Arrow">
<classdef><class>Arrow</class><classinfo>Arrow</classinfo></classdef>
<para>Constructor: Arrow(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the cylinder axis (vectors)</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VPython.Cone" xreflabel="Scientific.Visualization.VPython.Cone">
<classdef><class>Cone</class><classinfo>Cone</classinfo></classdef>
<para>Constructor: Cone(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the cylinder axis (vectors).
                      <parameter>point1</parameter> is the tip of the cone.</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VPython.PolyLines" xreflabel="Scientific.Visualization.VPython.PolyLines">
<classdef><class>PolyLines</class><classinfo>Multiple connected lines</classinfo></classdef>
<para>Constructor: PolyLines(<parameter>points</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>points</parameter></term>
<listitem><para>
a sequence of points to be connected by lines</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VPython.Line" xreflabel="Scientific.Visualization.VPython.Line">
<classdef><class>Line</class><classinfo>Line</classinfo></classdef>
<para>Constructor: Line(<parameter>point1</parameter>, <parameter>point2</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the line (vectors)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VPython.Polygons" xreflabel="Scientific.Visualization.VPython.Polygons">
<classdef><class>Polygons</class><classinfo>Polygons</classinfo></classdef>
<para>Constructor: Polygons(<parameter>points</parameter>, <parameter>index_lists</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>points</parameter></term>
<listitem><para>
a sequence of points</para></listitem></varlistentry>
<varlistentry><term><parameter>index_lists</parameter></term>
<listitem><para>
a sequence of index lists, one for each polygon.
                 The index list for a polygon defines which points
                 in <parameter>points</parameter> are vertices of the polygon.</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VPython.Material" xreflabel="Scientific.Visualization.VPython.Material">
<classdef><class>Material</class><classinfo>Material for graphics objects</classinfo></classdef>
<para>A material defines the color and surface properties of an object.</para>
<para>Constructor: Material(**|attributes|)</para>
<para>The attributes are "ambient_color", "diffuse_color", "specular_color",
"emissive_color", "shininess", and "transparency".
</para>
</classdescription>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Visualization.VPython.DiffuseMaterial" xreflabel="Scientific.Visualization.VPython.DiffuseMaterial" role="Python"><funcprototype><funcdef><function>DiffuseMaterial</function></funcdef>
<paramdef><parameter>color</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns a material with the <literal role="Python">diffuse color</literal> attribute set to <parameter>color</parameter>.</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Visualization.VPython.EmissiveMaterial" xreflabel="Scientific.Visualization.VPython.EmissiveMaterial" role="Python"><funcprototype><funcdef><function>EmissiveMaterial</function></funcdef>
<paramdef><parameter>color</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns a material with the <literal role="Python">emissive color</literal> attribute set to <parameter>color</parameter>.</para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.Visualization.VRML" xreflabel="Scientific.Visualization.VRML">
<title>Module Scientific.Visualization.VRML</title>

<para>This module provides definitions of simple 3D graphics objects and
VRML scenes containing them. The objects are appropriate for data
visualization, not for virtual reality modelling. Scenes can be written
to VRML files or visualized immediately using a VRML browser, whose
name is taken from the environment variable VRMLVIEWER (under Unix).</para>
<example><title>There are a few attributes that are common to all graphics objects:</title><para><variablelist>
<varlistentry><term>material</term>
<listitem><para>
a Material object defining color and surface properties</para></listitem></varlistentry>
<varlistentry><term>comment</term>
<listitem><para>
a comment string that will be written to the VRML file</para></listitem></varlistentry>
<varlistentry><term>reuse</term>
<listitem><para>
a boolean flag (defaulting to false). If set to one,
           the object may share its VRML definition with other
           objects. This reduces the size of the VRML file, but
           can yield surprising side effects in some cases.</para></listitem></varlistentry>
</variablelist></para>
</example>
<para>This module used the original VRML definition, version 1.0. For the
newer VRML 2 or VRML97, use the module VRML2, which uses exactly the
same interface. There is another almost perfectly compatible module
VMD, which produces input files for the molecular visualization program
VMD.</para>
<para>Example:</para>
<programlisting role="Python">
from Scientific.Visualization.VRML import *
scene = Scene([])
scale = ColorScale(10.)
for x in range(11):
    color = scale(x)
    scene.addObject(Cube(Vector(x, 0., 0.), 0.2,
                         material=Material(diffuse_color = color)))
scene.view()
</programlisting><classdescription role="Python" id="Class:Scientific.Visualization.VRML.Scene" xreflabel="Scientific.Visualization.VRML.Scene">
<classdef><class>Scene</class><classinfo>VRML scene</classinfo></classdef>
<para>A VRML scene is a collection of graphics objects that can be
written to a VRML file or fed directly to a VRML browser.</para>
<para>Constructor: Scene(<parameter>objects</parameter>=None, <parameter>cameras</parameter>=None, **|options|)</para>
<para><variablelist>
<varlistentry><term><parameter>objects</parameter></term>
<listitem><para>
a list of graphics objects or <literal role="Python">None</literal> for an empty scene</para></listitem></varlistentry>
<varlistentry><term><parameter>cameras</parameter></term>
<listitem><para>
a list of cameras (not yet implemented)</para></listitem></varlistentry>
<varlistentry><term><parameter>options</parameter></term>
<listitem><para>
options as keyword arguments (none defined at the moment;
             this argument is provided for compatibility with
             other modules)
</para></listitem></varlistentry>
</variablelist></para>
<methoddescription><methoddef><method>addObject</method></methoddef>
<paramdef><parameter>object</parameter></paramdef>
<para>Adds <parameter>object</parameter> to the list of graphics objects.</para>
</methoddescription>
<methoddescription><methoddef><method>addCamera</method></methoddef>
<paramdef><parameter>camera</parameter></paramdef>
<para>Adds <parameter>camers</parameter> to the list of cameras.</para>
</methoddescription>
<methoddescription><methoddef><method>writeToFile</method></methoddef>
<paramdef><parameter>filename</parameter></paramdef>
<para>Writes the scene to a VRML file with name <parameter>filename</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>view</method></methoddef>
<void/><para>Start a VRML browser for the scene.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML.Sphere" xreflabel="Scientific.Visualization.VRML.Sphere">
<classdef><class>Sphere</class><classinfo>Sphere</classinfo></classdef>
<para>Constructor: Sphere(<parameter>center</parameter>, <parameter>radius</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>center</parameter></term>
<listitem><para>
the center of the sphere (a vector)</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the sphere radius (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML.Cube" xreflabel="Scientific.Visualization.VRML.Cube">
<classdef><class>Cube</class><classinfo>Cube</classinfo></classdef>
<para>Constructor: Cube(<parameter>center</parameter>, <parameter>edge</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>center</parameter></term>
<listitem><para>
the center of the cube (a vector)</para></listitem></varlistentry>
<varlistentry><term><parameter>edge</parameter></term>
<listitem><para>
the length of an edge  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute</para></listitem></varlistentry>
</variablelist></para>
<para>The edges of a cube are always parallel to the coordinate axes.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML.Cylinder" xreflabel="Scientific.Visualization.VRML.Cylinder">
<classdef><class>Cylinder</class><classinfo>Cylinder</classinfo></classdef>
<para>Constructor: Cylinder(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>,
                      <parameter>faces</parameter>=<literal role="Python">(1, 1, 1)</literal>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the cylinder axis (vectors)</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute</para></listitem></varlistentry>
<varlistentry><term><parameter>faces</parameter></term>
<listitem><para>
a sequence of three boolean flags, corresponding to
           the cylinder hull and the two circular end pieces,
           specifying for each of these parts whether it is visible
           or not.
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML.Cone" xreflabel="Scientific.Visualization.VRML.Cone">
<classdef><class>Cone</class><classinfo>Cone</classinfo></classdef>
<para>Constructor: Cone(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>, <parameter>face</parameter>=<literal role="Python">1</literal>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the cylinder axis (vectors).
                      <parameter>point1</parameter> is the tip of the cone.</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute</para></listitem></varlistentry>
<varlistentry><term><parameter>face</parameter></term>
<listitem><para>
a boolean flag, specifying if the circular bottom is visible
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML.Line" xreflabel="Scientific.Visualization.VRML.Line">
<classdef><class>Line</class><classinfo>Line</classinfo></classdef>
<para>Constructor: Line(<parameter>point1</parameter>, <parameter>point2</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the line (vectors)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML.PolyLines" xreflabel="Scientific.Visualization.VRML.PolyLines">
<classdef><class>PolyLines</class><classinfo>Multiple connected lines</classinfo></classdef>
<para>Constructor: PolyLines(<parameter>points</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>points</parameter></term>
<listitem><para>
a sequence of points to be connected by lines</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML.Polygons" xreflabel="Scientific.Visualization.VRML.Polygons">
<classdef><class>Polygons</class><classinfo>Polygons</classinfo></classdef>
<para>Constructor: Polygons(<parameter>points</parameter>, <parameter>index_lists</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>points</parameter></term>
<listitem><para>
a sequence of points</para></listitem></varlistentry>
<varlistentry><term><parameter>index_lists</parameter></term>
<listitem><para>
a sequence of index lists, one for each polygon.
                 The index list for a polygon defines which points
                 in <parameter>points</parameter> are vertices of the polygon.</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML.Arrow" xreflabel="Scientific.Visualization.VRML.Arrow">
<classdef><class>Arrow</class><classinfo>Arrow</classinfo></classdef>
<para>An arrow consists of a cylinder and a cone.</para>
<para>Constructor: Arrow(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the arrow (vectors).
                      <parameter>point2</parameter> defines the tip of the arrow.</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius of the arrow shaft (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML.Material" xreflabel="Scientific.Visualization.VRML.Material">
<classdef><class>Material</class><classinfo>Material for graphics objects</classinfo></classdef>
<para>A material defines the color and surface properties of an object.</para>
<para>Constructor: Material(**|attributes|)</para>
<para>The attributes are "ambient_color", "diffuse_color", "specular_color",
"emissive_color", "shininess", and "transparency".
</para>
</classdescription>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Visualization.VRML.DiffuseMaterial" xreflabel="Scientific.Visualization.VRML.DiffuseMaterial" role="Python"><funcprototype><funcdef><function>DiffuseMaterial</function></funcdef>
<paramdef><parameter>color</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns a material with the <literal role="Python">diffuse color</literal> attribute set to <parameter>color</parameter>.</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Visualization.VRML.EmissiveMaterial" xreflabel="Scientific.Visualization.VRML.EmissiveMaterial" role="Python"><funcprototype><funcdef><function>EmissiveMaterial</function></funcdef>
<paramdef><parameter>color</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns a material with the <literal role="Python">emissive color</literal> attribute set to <parameter>color</parameter>.</para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="Module:Scientific.Visualization.VRML2" xreflabel="Scientific.Visualization.VRML2">
<title>Module Scientific.Visualization.VRML2</title>

<para>This module provides definitions of simple 3D graphics objects and
VRML scenes containing them. The objects are appropriate for data
visualization, not for virtual reality modelling. Scenes can be written
to VRML files or visualized immediately using a VRML browser, whose
name is taken from the environment variable VRML2VIEWER (under Unix).</para>
<example><title>There are a few attributes that are common to all graphics objects:</title><para><variablelist>
<varlistentry><term>material</term>
<listitem><para>
a Material object defining color and surface properties</para></listitem></varlistentry>
<varlistentry><term>comment</term>
<listitem><para>
a comment string that will be written to the VRML file</para></listitem></varlistentry>
<varlistentry><term>reuse</term>
<listitem><para>
a boolean flag (defaulting to false). If set to one,
           the object may share its VRML definition with other
           objects. This reduces the size of the VRML file, but
           can yield surprising side effects in some cases.</para></listitem></varlistentry>
</variablelist></para>
</example>
<para>This module used the VRML 2.0 definition, also known as VRML97. For
the original VRML 1, use the module VRML, which uses exactly the same
interface. There is another almost perfectly compatible module VMD,
which produces input files for the molecular visualization program
VMD.</para>
<para>Example:</para>
<programlisting role="Python">
from Scientific.Visualization.VRML2 import *
scene = Scene([])
scale = ColorScale(10.)
for x in range(11):
    color = scale(x)
    scene.addObject(Cube(Vector(x, 0., 0.), 0.2,
                         material=Material(diffuse_color = color)))
scene.view()
</programlisting><classdescription role="Python" id="Class:Scientific.Visualization.VRML2.Scene" xreflabel="Scientific.Visualization.VRML2.Scene">
<classdef><class>Scene</class><classinfo>VRML scene</classinfo></classdef>
<para>A VRML scene is a collection of graphics objects that can be
written to a VRML file or fed directly to a VRML browser.</para>
<para>Constructor: Scene(<parameter>objects</parameter>=None, <parameter>cameras</parameter>=None, **|options|)</para>
<para><variablelist>
<varlistentry><term><parameter>objects</parameter></term>
<listitem><para>
a list of graphics objects or <literal role="Python">None</literal> for an empty scene</para></listitem></varlistentry>
<varlistentry><term><parameter>cameras</parameter></term>
<listitem><para>
a list of cameras</para></listitem></varlistentry>
<varlistentry><term><parameter>options</parameter></term>
<listitem><para>
options as keyword arguments (none defined at the moment;
             this argument is provided for compatibility with
             other modules)
</para></listitem></varlistentry>
</variablelist></para>
<methoddescription><methoddef><method>addObject</method></methoddef>
<paramdef><parameter>object</parameter></paramdef>
<para>Adds <parameter>object</parameter> to the list of graphics objects.</para>
</methoddescription>
<methoddescription><methoddef><method>addCamera</method></methoddef>
<paramdef><parameter>camera</parameter></paramdef>
<para>Adds <parameter>camera</parameter> to the list of cameras.</para>
</methoddescription>
<methoddescription><methoddef><method>writeToFile</method></methoddef>
<paramdef><parameter>filename</parameter></paramdef>
<para>Writes the scene to a VRML file with name <parameter>filename</parameter>.</para>
</methoddescription>
<methoddescription><methoddef><method>view</method></methoddef>
<void/><para>Start a VRML browser for the scene.</para>
</methoddescription>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.Camera" xreflabel="Scientific.Visualization.VRML2.Camera">
<classdef><class>Camera</class><classinfo>Camera/viewpoint for a scene</classinfo></classdef>
<para>Constructor: Camera(<parameter>position</parameter>, <parameter>orientation</parameter>, <parameter>description</parameter>,
                    <parameter>field_of_view</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>position</parameter></term>
<listitem><para>
the location of the camera (a vector)</para></listitem></varlistentry>
<varlistentry><term><parameter>orientation</parameter></term>
<listitem><para>
an (axis, angle) tuple in which the axis is
                 a vector and angle a number (in radians);
                 axis and angle specify a rotation with respect
                 to the standard orientation along the negative z axis</para></listitem></varlistentry>
<varlistentry><term><parameter>description</parameter></term>
<listitem><para>
a label for the viewpoint (a string)</para></listitem></varlistentry>
<varlistentry><term><parameter>field_of_view</parameter></term>
<listitem><para>
the field of view (a positive number)
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.NavigationInfo" xreflabel="Scientific.Visualization.VRML2.NavigationInfo">
<classdef><class>NavigationInfo</class><classinfo>Navigation Information</classinfo></classdef>
<para>Constructor: NavigationInfo(<parameter>speed</parameter>, <parameter>type</parameter>)</para>
<para><variablelist>
<varlistentry><term><parameter>speed</parameter></term>
<listitem><para>
walking speed in length units per second</para></listitem></varlistentry>
<varlistentry><term><parameter>type</parameter></term>
<listitem><para>
one of <literal role="Python">WALK</literal>, <literal role="Python">EXAMINE</literal>, <literal role="Python">FLY</literal>, <literal role="Python">NONE</literal>, <literal role="Python">ANY</literal>
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.Sphere" xreflabel="Scientific.Visualization.VRML2.Sphere">
<classdef><class>Sphere</class><classinfo>Sphere</classinfo></classdef>
<para>Constructor: Sphere(<parameter>center</parameter>, <parameter>radius</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>center</parameter></term>
<listitem><para>
the center of the sphere (a vector)</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the sphere radius (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.Cube" xreflabel="Scientific.Visualization.VRML2.Cube">
<classdef><class>Cube</class><classinfo>Cube</classinfo></classdef>
<para>Constructor: Cube(<parameter>center</parameter>, <parameter>edge</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>center</parameter></term>
<listitem><para>
the center of the cube (a vector)</para></listitem></varlistentry>
<varlistentry><term><parameter>edge</parameter></term>
<listitem><para>
the length of an edge  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute</para></listitem></varlistentry>
</variablelist></para>
<para>The edges of a cube are always parallel to the coordinate axes.
</para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.Cylinder" xreflabel="Scientific.Visualization.VRML2.Cylinder">
<classdef><class>Cylinder</class><classinfo>Cylinder</classinfo></classdef>
<para>Constructor: Cylinder(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>,
                      <parameter>faces</parameter>=<literal role="Python">(1, 1, 1)</literal>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the cylinder axis (vectors)</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute</para></listitem></varlistentry>
<varlistentry><term><parameter>faces</parameter></term>
<listitem><para>
a sequence of three boolean flags, corresponding to
           the cylinder hull and the two circular end pieces,
           specifying for each of these parts whether it is visible
           or not.
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.Cone" xreflabel="Scientific.Visualization.VRML2.Cone">
<classdef><class>Cone</class><classinfo>Cone</classinfo></classdef>
<para>Constructor: Cone(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>, <parameter>face</parameter>=<literal role="Python">1</literal>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the cylinder axis (vectors).
                      <parameter>point1</parameter> is the tip of the cone.</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius  (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute</para></listitem></varlistentry>
<varlistentry><term><parameter>face</parameter></term>
<listitem><para>
a boolean flag, specifying if the circular bottom is visible
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.Line" xreflabel="Scientific.Visualization.VRML2.Line">
<classdef><class>Line</class><classinfo>Line</classinfo></classdef>
<para>Constructor: Line(<parameter>point1</parameter>, <parameter>point2</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the line (vectors)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.PolyLines" xreflabel="Scientific.Visualization.VRML2.PolyLines">
<classdef><class>PolyLines</class><classinfo>Multiple connected lines</classinfo></classdef>
<para>Constructor: PolyLines(<parameter>points</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>points</parameter></term>
<listitem><para>
a sequence of points to be connected by lines</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.Polygons" xreflabel="Scientific.Visualization.VRML2.Polygons">
<classdef><class>Polygons</class><classinfo>Polygons</classinfo></classdef>
<para>Constructor: Polygons(<parameter>points</parameter>, <parameter>index_lists</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>points</parameter></term>
<listitem><para>
a sequence of points</para></listitem></varlistentry>
<varlistentry><term><parameter>index_lists</parameter></term>
<listitem><para>
a sequence of index lists, one for each polygon.
                 The index list for a polygon defines which points
                 in <parameter>points</parameter> are vertices of the polygon.</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.Arrow" xreflabel="Scientific.Visualization.VRML2.Arrow">
<classdef><class>Arrow</class><classinfo>Arrow</classinfo></classdef>
<para>An arrow consists of a cylinder and a cone.</para>
<para>Constructor: Arrow(<parameter>point1</parameter>, <parameter>point2</parameter>, <parameter>radius</parameter>, **|attributes|)</para>
<para><variablelist>
<varlistentry><term><parameter>point1</parameter>, <parameter>point2</parameter></term>
<listitem><para>
the end points of the arrow (vectors).
                      <parameter>point2</parameter> defines the tip of the arrow.</para></listitem></varlistentry>
<varlistentry><term><parameter>radius</parameter></term>
<listitem><para>
the radius of the arrow shaft (a positive number)</para></listitem></varlistentry>
<varlistentry><term><parameter>attributes</parameter></term>
<listitem><para>
any graphics object attribute
</para></listitem></varlistentry>
</variablelist></para>
</classdescription>

<classdescription role="Python" id="Class:Scientific.Visualization.VRML2.Material" xreflabel="Scientific.Visualization.VRML2.Material">
<classdef><class>Material</class><classinfo>Material for graphics objects</classinfo></classdef>
<para>A material defines the color and surface properties of an object.</para>
<para>Constructor: Material(**|attributes|)</para>
<para>The attributes are "ambient_color", "diffuse_color", "specular_color",
"emissive_color", "shininess", and "transparency".
</para>
</classdescription>

<sect3>
<title>Functions</title>
<itemizedlist>
<listitem><para>
<funcsynopsis id="Function:Scientific.Visualization.VRML2.DiffuseMaterial" xreflabel="Scientific.Visualization.VRML2.DiffuseMaterial" role="Python"><funcprototype><funcdef><function>DiffuseMaterial</function></funcdef>
<paramdef><parameter>color</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns a material with the <literal role="Python">diffuse color</literal> attribute set to <parameter>color</parameter>.</para>
</listitem>
<listitem><para>
<funcsynopsis id="Function:Scientific.Visualization.VRML2.EmissiveMaterial" xreflabel="Scientific.Visualization.VRML2.EmissiveMaterial" role="Python"><funcprototype><funcdef><function>EmissiveMaterial</function></funcdef>
<paramdef><parameter>color</parameter></paramdef>
</funcprototype></funcsynopsis>
</para>
<para>Returns a material with the <literal role="Python">emissive color</literal> attribute set to <parameter>color</parameter>.</para>
</listitem>
</itemizedlist>
</sect3>
</sect2>

</sect1>

<sect1 id="Module:Scientific.indexing" xreflabel="Scientific.indexing">
<title>Module Scientific.indexing</title>

<para>This module provides a convenient method for constructing
array indices algorithmically. It provides one importable object,
<literal role="Python">index_expression</literal>.</para>
<para>For any index combination, including slicing and axis insertion,
<literal role="Python">a[indices]</literal> is the same as <literal role="Python">a[index_expression[indices]]</literal> for any
array <literal role="Python">a</literal>. However, <literal role="Python">index_expression[indices]</literal> can be used anywhere
in Python code and returns a tuple of indexing objects that can be
used in the construction of complex index expressions.</para>
<para>Sole restriction: Slices must be specified in the double-colon
form, i.e. a[::] is allowed, whereas a[:] is not.
</para>
</sect1>

</chapter>



</book>
